Enumerations too hi(enumeration: nested) hi(nested enumerations) may be nested
in classes. Nesting enumerations is a good way to show the close connection
between the enumeration and its class. In the class ti(ios) we've seen values
like ti(ios::beg) and ti(ios::cur). In the current i(Gnu) bf(C++)
implementation these values are defined as values in the ti(seek_dir)
enumeration:
        verb(
    class ios: public _ios_fields
    {
        public:
            enum seek_dir
            {
                beg,
                cur,
                end
            };
    };
        )
    For illustration purposes, let's assume that a class tt(DataStructure)
may be traversed in a forward or backward direction. Such a class can define
an enumeration tt(Traversal) having the values tt(forward) and
tt(backward). Furthermore, a member function tt(setTraversal()) can be defined
requiring either of the two enumeration values. The class can be defined as
follows:
        verb(
    class DataStructure
    {
        public:
            enum Traversal
            {
                forward,
                backward
            };
            setTraversal(Traversal mode);
        private:
            Traversal
                d_mode;
    };
        )
    Within the class tt(DataStructure) the values of the tt(Traversal)
enumeration can be used directly. For example:
        verb(
    void DataStructure::setTraversal(Traversal mode)
    {
        d_mode = mode;
        switch (d_mode)
        {
            forward:
            break;

            backward:
            break;
        }
    }
        )
    Ouside of the class tt(DataStructure) the name of the enumeration type is
not used to refer to the values of the enumeration. Here the classname is
sufficient. Only if a variable of the enumeration type is required the name of
the enumeration type is needed, as illustrated by the following piece of code:
        verb(
    void fun()
    {
        DataStructure::Traversal                // enum typename required
            localMode = DataStructure::forward; // enum typename not required

        DataStructure ds;
                                                // enum typename not required
        ds.setTraversal(DataStructure::backward);
    }
        )
    Again, only if tt(DataStructure) defines a nested class tt(Nested), in
turn defining the enumeration tt(Traversal), the two class scopes are
required. In that case the latter example should have been coded as follows:
        verb(
    void fun()
    {
        DataStructure::Nested::Traversal
            localMode = DataStructure::Nested::forward;

        DataStructure ds;

        ds.setTraversal(DataStructure::Nested::backward);
    }
        )
