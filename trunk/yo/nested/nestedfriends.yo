To grant nested classes access rights to the private members of their
surrounding class, to grant access to the private members of other nested
classes, or to grant a surrounding class access to the private members of its
nested classes the hi(friend: nested classes)tt(friend) keyword must be used.

Consider the following situation where a class tt(Surround) has two nested
classes tt(FirstWithin) and tt(SecondWithin). Each of the three classes has a
static data member tt(int s_variable):
        verb(
    class Surround
    {
        static int s_variable;
        public:
            class FirstWithin
            {
                static int s_variable;
                public:
                    int value();
            };
            int value();
        private:
            class SecondWithin
            {
                static int s_variable;
                public:
                    int value();
            };
    };
        )
    If the class tt(Surround) should be able to access tt(FirstWithin) and
tt(SecondWithin)'s private members, these latter two classes must declare
tt(Surround) to be their friend. The function tt(Surround::value) can
thereupon access the private members of its nested classes. For example (note
the tt(friend) declarations in the two nested classes):
        verb(
    class Surround
    {
        static int s_variable;
        public:
            class FirstWithin
            {
                friend class Surround;
                static int s_variable;
                public:
                    int value();
            };
            int value();
        private:
            class SecondWithin
            {
                friend class Surround;
                static int s_variable;
                public:
                    int value();
            };
    };
    inline int Surround::FirstWithin::value()
    {
        FirstWithin::s_variable = SecondWithin::s_variable;
        return (s_variable);
    }
        )
    To allow the nested classes access to the private members of their
surrounding class, the class tt(Surround) must declare its nested classes as
friends. As the tt(friend) keyword may only be used when the class that is to
become a friend is already known as a class by the compiler, either a
i(forward declaration) of the nested classes is required (to be followed by
the friend declaration), or the friend declaration follows the definition of
the nested classes. The forward declaration followed by the friend declaration
looks like this:
        verb(
    class Surround
    {
        public:
            class FirstWithin;
            class SecondWithin;
            friend class FirstWithin;
            friend class SecondWithin;
            class FirstWithin
            { ... };
        ...
    };
        )
    Alternatively, the friend declaration may follow the definition of the
classes. A class can be declared a friend following its definition, with
in-class code already using the fact that it will be declared a friend of the
outer class. Furthermore, in-class defined nested class members may already
use members of the surrounding class that have not yet been seen by the
compiler. Finally note that `tt(s_variable)' which is
  hi(nested class: member access) defined in the class tt(Surround) may be
accessed by the nested classes as tt(Surround::s_variable):
        verb(
    class Surround
    {
        static int s_variable;
        public:
            class FirstWithin
            {
                friend class Surround;
                static int s_variable;
                public:
                    int value();
            };
            friend class FirstWithin;
            int value();

        private:
            class SecondWithin
            {
                friend class Surround;
                static int s_variable;
                public:
                    int value();
            };
            static void classMember();

            friend class SecondWithin;
    };
    inline int Surround::value()
    {
        FirstWithin::s_variable = SecondWithin::s_variable;
        return s_variable;
    }
    inline int Surround::FirstWithin::value()
    {
        Surround::s_variable = 4;
        Surround::classMember();
        return s_variable;
    }
    inline int Surround::SecondWithin::value()
    {
        Surround::s_variable = 40;
        return s_variable;
    }
        )
    Finally, tt(friend) declarations must be applied to grant the nested
classes access to each other's private members. To grant tt(FirstWithin)
access to tt(SecondWithin)'s private members nothing but a tt(friend)
declaration in tt(SecondWithin) is required. However, to grant
tt(SecondWithin) access to tt(FirstWithin)'s private members the class
tt(FirstWithin) cannot simply use tt(friend class SecondWithin), as
tt(SecondWithin)'s definition is as yet unknown. A i(forward declaration) of
tt(SecondWithin) is required and this forward declaration must be provided by
the class tt(Surround), rather than by the class tt(FirstWithin).

    Clearly, a forward declaration like `tt(class SecondWithin)' makes no
sense in the class
tt(FirstWithin) itself, as this would refer to an external
(global) class tt(SecondWithin). Likewise, the
forward declaration of the nested class tt(SecondWithin) cannot be provided
inside
tt(FirstWithin) as tt(class Surround::SecondWithin). Doing so would generate
the following error message:
        quote(`Surround' does not have a nested type named `SecondWithin')

Here the class tt(SecondWithin) must be declared by the class tt(Surround),
before the class tt(FirstWithin) has been defined. This way tt(SecondWithin)'s
friend declaration is accepted inside tt(FirstWithin).

The following example shows the classes having full access to all private
members of all classes:
        verb(
    class Surround
    {
        class SecondWithin;
        static int s_variable;
        public:
            class FirstWithin
            {
                friend class Surround;
                friend class SecondWithin;
                static int s_variable;
                public:
                    int value();
            };
            friend class FirstWithin;
            int value();
        private:
            class SecondWithin
            {
                friend class Surround;
                friend class FirstWithin;
                static int s_variable;
                public:
                    int value();
            };
            friend class SecondWithin;
    };
    inline int Surround::value()
    {
        FirstWithin::s_variable = SecondWithin::s_variable;
        return s_variable;
    }
    inline int Surround::FirstWithin::value()
    {
        Surround::s_variable = SecondWithin::s_variable;
        return s_variable;
    }
    inline int Surround::SecondWithin::value()
    {
        Surround::s_variable = FirstWithin::s_variable;
        return s_variable;
    }
        )
