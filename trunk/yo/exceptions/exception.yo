In bf(C++) em(exceptions) are the best alternative to
    hi(setjmp(): alternative to) tt(setjmp()) and
    hi(longjmp(): alternative to) tt(longjmp()). In this section an example
using exceptions is presented. Again, the program is derived from the basic
program, given in section ref(BASICEXCEPTION):
        verbinclude(exceptions/examples/exception.cc)
    In this program an emi(exception) is thrown, where a tt(longjmp()) was
used in the program in section ref(EXCEPTIONJMP). The comparable construct for
the tt(setjmp()) call in that program is represented here by the ti(try) and
ti(catch) blocks. The tt(try) block surrounds statements (including function
calls) in which exceptions are thrown, the tt(catch) block may contain
statements to be executed just after throwing an exception.

    So, comparably to the example given in section ref(EXCEPTIONJMP), the
function tt(Inner::fun()) terminates, albeit with an exception rather than by
a call to tt(longjmp()). The exception is caught in tt(main()), and the
program terminates. When the output from the current program is inspected, we
notice that the destructor of the tt(Inner) object, created in
tt(Outer::fun()) is now correctly called. Also notice that the execution of
the function tt(Inner::fun()) really terminates at the tt(throw) statement:
the insertion of the text into tt(cout), just beyond the tt(throw) statement,
doesn't take place.

    Hopefully this has raised your appetite for exceptions, since it was shown
that:
    itemization(
    it() Exceptions provide a means to break out of the normal flow control
without having to use a cascade of tt(return)-statements, and without the need
to terminate the program.
    it() Exceptions do not disrupt the activation of destructors, and are
therefore strongly preferred over the use of ti(setjmp()) and ti(longjmp()).
    )
