    Only constructed objects are eventually destroyed. Although this may sound
like a truism, there is a subtlety here. If the construction of an object
fails for some reason, the object's destructor will not be called once the
object goes out of scope. This could happen if an emi(uncaught exception)
        hi(exception: uncaught)
        hi(constructor: throwing exceptions)
    is generated by the constructor. If the exception is thrown em(after) the
object has allocated some memory, then its destructor (as it isn't called)
won't be able to delete the allocated block of memory. A em(memory leak) will
be the result.

    The following example illustrates this situation in its prototypical
form. The constructor of the class tt(Incomplete) first displays a message
and then throws an exception. Its destructor also displays a message:
        verbinsert(INCOMPLETE)(exceptions/examples/constructor.cc)
    Next, tt(main()) creates an tt(Incomplete) object inside a tt(try)
block. Any exception that may be generated is subsequently caught:
        verbinsert(MAIN)(exceptions/examples/constructor.cc)
    When this program is run, it produces the following output:
        verb(
    Creating `Incomplete' object
    Allocated some memory
    Caught exception
        )
    Thus, if tt(Incomplete)'s constructor would actually have allocated some
memory, the program would suffer from a memory leak. To prevent this from
happening, the following countermeasures are available:
    itemization(
    it() Exceptions should not leave the constructor. If part of the
constructor's code may generate exceptions, then this part should itself be
surrounded by a tt(try) block, catching the exception within the
constructor. There may be good reasons for throwing exceptions out of the
constructor, as that is a direct way to inform the code using the constructor
that the object has not become available. But before the exception leaves the
constructor, it should be given a chance to delete memory it already has
allocated. The following skeleton setup of a constructor shows how this can be
realized. Note how any exception that may have been generated is rethrown,
allowing external code to inspect this exception too:
        verb(
    Incomplete::Incomplete()
    {
        try
        {
            d_memory = new Type;
            code_maybe_throwing_exceptions();
        }
        catch (...)
        {
            delete d_memory;
            throw;
        }
    };
        )
    it() Exceptions might be generated while initializing members. In those
cases, a tt(try) block within the constructor's body has no chance to catch
such exceptions. When a class uses pointer data members, and exceptions are
generated em(after) these pointer data members have been initialized, memory
leaks can still be avoided, though. This is accomplished by using em(smart
pointers), e.g., em(auto_ptr) objects, introduced in section ref(AUTOPTR). As
tt(auto_ptr) objects are objects, their destructors are still called, even
when their the full construction of their composing object fails. In this case
the rule em(once an object has been constructed its destructor is called when
the object goes out of scope) still applies.

    Section ref(AUTOCONS) covers the use of tt(auto_ptr) objects to prevent
memory leaks when exceptions are thrown out of constructors, even if the
exception is generated by a member initializer.

    bf(C++), however, supports an even more generic way to prevent exceptions
from leaving functions (or constructors):
    emi(function try block)em(s). These function try blocks are discussed in
the next section.
    )
    Destructors have problems of their own when they generate
exceptions. Exceptions leaving destructors may of course produce memory leaks,
as not all allocated memory may already have been deleted when the exception
is generated. Other forms of incomplete handling may be encountered. For
example, a database class may store modifications of its database in memory,
leaving the update of file containing the database file to its destructor. If
the destructor generates an exception before the file has been updated, then
there will be no update. But another, far more subtle, consequence of
exceptions leaving destructors exist.

    The situation we're about to discuss may be compared to a carpenter
building a cupboard containing a single drawer. The cupboard is finished, and
a customer, buying the cupboard, finds that the cupboard can be used as
expected. Satisfied with the cupboard, the customer asks the carpenter to
build another cupboard, this time containing em(two) drawers. When the second
cupboard is finished, the customer takes it home and is utterly amazed when
the second cupboard completely collapses immediately after its first use.

    Weird story? Consider the following program:
        verbinsert(MAIN)(exceptions/examples/destructor.cc)
    When this program is run it produces the following output:
        verb(
    Creating Cupboard1
    Drawer 1 used
    Cupboard1 behaves as expected
    Creating Cupboard2
    Drawer 2 used
    Drawer 1 used
    Abort
        )
    The final tt(Abort) indicating that the program has aborted, instead of
displaying a message like tt(Cupboard2 behaves as expected). Now let's have a
look at the three classes involved. The class tt(Drawer) has no particular
characteristics, except that its destructor throws an exception:
        verbinsert(DRAWER)(exceptions/examples/destructor.cc)
    The class tt(Cupboard1) has no special characteristics at all. It merely
has a single composed tt(Drawer) object:
        verbinsert(CUP1)(exceptions/examples/destructor.cc)
    The class tt(Cupboard2) is constructed comparably, but it has two
composed tt(Drawer) objects:
        verbinsert(CUP2)(exceptions/examples/destructor.cc)

    When tt(Cupboard1)'s destructor is called, tt(Drawer)'s destructor is
eventually called to destroy its composed object. This destructor throws an
exception, which is caught beyond the program's first tt(try) block. This
behavior is completely as expected. However, a problem occurs when
tt(Cupboard2)'s destructor is called. Of its two composed objects, the
destructor of the second tt(Drawer) is called first.  This destructor throws
an exception, which ought to be caught beyond the program's second tt(try)
block. However, although the flow of control by then has left the context of
tt(Cupboard2)'s destructor, that object hasn't completely been destroyed yet
as the destructor of its other (left) tt(Drawer) still has to be
called. Normally that would not be a big problem: once the exception leaving
tt(Cupboard2)'s destructor is thrown, any remaining actions would simply be
ignored, albeit that (as both drawers are properly constructed objects)
tt(left)'s destructor would still be called. So this happens here
too. However, tt(left)'s destructor em(also) throws an exception. Since we've
already left the context of the second tt(try) block, the programmed
flow control is completely mixed up, and the program has no other option but
to abort. It does so by calling tt(terminate()), which in turn calls
tt(abort()). Here we have our collapsing cupboard having two drawers, even
though the cupboard having one drawer behaves perfectly.

    The program aborts since there are multiple composed objects whose
destructors throw exceptions leaving the destructors. In this situation one of
the composed objects would throw an exception by the time the program's flow
control has already left its proper context. This causes the program to abort.

    This situation can be prevented if we ensure that exceptions
em(never) leave destructors. In the cupboard example, tt(Drawer)'s destructor
throws an exception leaving the destructor. This should not happen: the
exception should be caught by tt(Drawer)'s destructor itself. Exceptions
should never be thrown out of destructors, as we might not be able to catch,
at an outer level, exceptions generated by destructors. As long as we view
destructors as service members performing tasks that are em(directly) related
to the object being destroyed, rather than a member on which we can base any
flow control, this should not be a serious limitation. Here is the skeleton of
a destructor whose code might throw exceptions:
        verb(
    Class::~Class()
    {
        try
        {
            maybe_throw_exceptions();
        }
        catch (...)
        {}
    }
        )
