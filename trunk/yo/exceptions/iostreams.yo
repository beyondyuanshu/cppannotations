The bf(C++) i(I/O) library was used well before exceptions were available in
bf(C++). Hence, normally the classes of the iostream library do not throw
exceptions. However, it is possible to modify that behavior using the
ti(ios::exceptions()) member function. This function has two overloaded
versions:
    itemization(
    itht(ios::exceptions())(iostate exceptions()): this member returns the
i(state flags) for which the stream will throw exceptions,
    itt(void exceptions(iostate state)): this member will throw an exception
when state hi(iostate) tt(state) is observed.
    )
    In the context of the I/O library, exceptions are objects of the class
ti(ios::failure), derived from ti(ios::exception). A tt(failure) object can be
constructed with a tt(string const &message), which can be retrieved using the
hi(failure::what()) tt(virtual char const *what() const) member.

    Exceptions should be used for exceptional situations. Therefore, we think
it is questionable to have stream objects throw exceptions for rather standard
situations like endOfFile(). Using exceptions to handle input errors might be
defensible, for example when input errors should not occur and imply a
corrupted file. But here we think aborting the program with an appropriate
error message usually would be a more appropriate action. Here is
an example showing the use of exceptions in an interactive program, expecting
numbers:
        verbinclude(exceptions/examples/ioexceptions.cc)
