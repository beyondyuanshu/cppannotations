The ti(catch) block contains code that is executed when an exception is
thrown. Since em(expressions) are thrown, the tt(catch)-block must know what
kind of exceptions it should be able to handle. Therefore, the keyword
tt(catch) is followed by a parameter list consisting of but one parameter,
which is the type of the exception handled by the tt(catch)
block.  So, an exception handler for tt(char const *) exceptions will have the
following form:
        verb(
    catch (char const *message)
    {
        // code to handle the message
    }
        )
    Earlier (section ref(THROW)) we've seen that such a message doesn't have
to be thrown as a static string. It's also possible for a function to return a
string, which is then thrown as an exception. If such a function
creates the string that is thrown as an exception em(dynamically), the
exception handler will normally have to delete the allocated memory to prevent
a i(memory leak).

Close attention should be paid to the nature of the parameter of the
exception handler, to make sure that
    hi(exception: dynamically generated)
dynamically generated exceptions are deleted once the handler has processed
them. Of course, when an exception is passed on to an outer level
exception handler, the received exception should em(not) be deleted by the
inner level handler.

Different kinds of exceptions may be thrown: tt(char *)s, tt(int)s, pointers
or references to objects, etc.: all these different types may be used in
throwing and catching exceptions. So, various types of exceptions may come out
of a tt(try)-block. In order to i(catch all expressions) that may emerge from
a tt(try)-block, multiple exception handlers (i.e., tt(catch)-blocks) may
follow the tt(try)-block.

To some extent the em(order) hi(exception handler: order) of the exception
handlers is important. When an exception is thrown, the first exception
handler matching the type of the thrown exception is used and remaining
exception handlers are ignored. So only one exception handler following a
tt(try)-block will be executed. Normally this is no problem: the thrown
exception is of a certain type, and the correspondingly typed catch-handler
will catch it. For example, if exception handlers are defined for
tt(char *)s and ti(void *)s then ASCII-Z strings will be caught by the latter
handler. Note that a tt(char *) can also be considered a  tt(void *), but even
so, an ASCII-Z string will be handled by a tt(char *) handler, and not by a
tt(void *) handler. This is true in general: handlers should be designed very
type specific to catch the correspondingly typed exception. For example,
tt(int)-exceptions are not caught by tt(double)-catchers, tt(char)-exceptions
are not caught by tt(int)-catchers. Here is a little example illustrating that
the order of the catchers is not important for types not having any
hierarchical relation to each other (i.e., tt(int) is not derived from
tt(double); tt(string) is not derived from ASCII-Z):
        verbinclude(exceptions/examples/catchers.cc)
    As an alternative to constructing different types of exception handlers
for different types of exceptions, a specific class can be designed whose
objects contain information about the exception. Such an approach was
mentioned earlier, in section ref(EMPTYTHROW). Using this approach, there's
only one handler required, since we em(know) we won't throw other types of
exceptions:
        verb(
    try
    {
        // code throws only Exception pointers
    }
    catch (Exception *e)
    {
        e->process();
        delete e;
    }
        )
    The tt(delete e) statement in the above code  indicates
that the tt(Exception) object was created dynamically.

When the code of an exception handler has been processed, execution continues
beyond the last exception handler directly following that tt(try)-block
(assuming the handler doesn't itself use flow control statements (like
tt(return) or tt(throw)) to break the default flow of execution). From this,
we distinguish the following hi(exception: cases) cases:
    itemization(
    it() If em(no) exception was thrown within the tt(try)-block no exception
handler is activated, and the execution continues from the last statement in
the tt(try)-block to the first statement beyond the last tt(catch)-block.
    it() If an exception em(was) thrown within the tt(try)-block but neither
the current level nor an other level contains an appropriate exception
handler, the program's i(default exception handler) is called, usually
aborting the program.
    it() If an exception was thrown from the tt(try)-block and an appropriate
exception handler is available, then the code of that exception handler is
executed. Following the execution of the code of the exception handler, the
execution of the program continues at the first statement beyond the last
tt(catch)-block.
    )
    All statements in a tt(try) block appearing below an executed
tt(throw)-statement will be hi(try block: ignoring statements)
ignored. However, destructors hi(try block: destructors in) of objects defined
locally in the tt(try)-block em(are) called, and they are called before any
exception handler's code is executed.

The actual hi(exception: construction of) computation or construction of an
exception may be realized using various degrees of sophistication. For
example, it's possible to use the operator tt(new); to use static member
functions of a class; to return a pointer to an object; or to use objects of
classes derived from a class, possibly involving polymorphism.
