The ti(try)-block surrounds statements in which exceptions may be thrown. As
we have seen, the actual tt(throw) statement can be placed everywhere, not
necessarily directly in the tt(try)-block. It may, for example, be placed in a
function, called from within the tt(try)-block.

The keyword tt(try) is followed by a set of curly braces, acting like a
standard bf(C++) i(compound statement): multiple statements and
definitions may be placed here.

It is possible (and very common) to create hi(exception: levels) em(levels) in
which exceptions may be thrown. For example, tt(main())'s code is surrounded
by a tt(try)-block, forming an outer level in which exceptions can be handled.
Within tt(main())'s tt(try)-block, functions are called which may also contain
tt(try)-blocks, forming the next level in which exceptions may be
generated. As we have seen (in section ref(EMPTYTHROW)), exceptions thrown in
inner level tt(try)-blocks may or may not be processed at that level. By
placing an hi(throw: empty) empty tt(throw) in an exception handler, the
thrown exception is passed on to the next (outer) level.

If an exception hi(exception: outside of try block)
    is thrown outside of any tt(try)-block, then the default
    hi(exception: default handling) way to handle (uncaught) exceptions is
used, which is normally to i(abort) the program. Try to compile and run the
following tiny program, and see what happens:
        verb(
    int main()
    {
        throw "hello";
    }
        )
