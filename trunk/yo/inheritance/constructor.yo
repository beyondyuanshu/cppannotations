As mentioned earlier, a derived class inherits the functionality from its
i(base class). In this section we shall describe the effects
    i(inheritance) has on the constructor of a derived class.

As will be clear from the definition of the class tt(Land), a i(constructor)
exists to set both the tt(weight) and the tt(speed) of an object. The
poor-man's implementation of this constructor could be:
        verb(
    Land::Land (size_t weight, size_t speed)
    {
        setWeight(weight);
        setspeed(speed);
    }
        )
    This implementation has the following disadvantage. The bf(C++) compiler
will generate code calling the base class's i(default constructor) from each
constructor in the i(derived class), unless explicitly instructed otherwise.
This can be compared to the situation we encountered in composed objects (see
section ref(Composition)).

Consequently, in the above implementation the
    i(default constructor) of tt(Vehicle) is called, which probably
initializes the weight of the vehicle, only to be redefined immediately
thereafter by the function tt(setWeight()).

    A more efficient approach is of course to call the constructor of
tt(Vehicle) expecting an tt(size_t weight) argument directly.  The syntax
achieving this is to mention the constructor to be called (supplied with its
arguments) immediately following the argument list of the constructor of the
derived class itself. Such a i(base class initializer) is shown in the next
example. Following the constructor's head a colon appears, which is then
followed by the base class constructor. Only then any member initializer may
be specified (using commas to separate multiple initializers), followed by the
constructor's body:
        verb(
    Land::Land(size_t weight, size_t speed)
    :
        Vehicle(weight)
    {
        setspeed(speed);
    }
        )
