Manipulators taking arguments are implemented as hi(macro) macros: they are
handled by the i(preprocessor), and are not available beyond the preprocessing
stage.  The problem appears to be that you can't call a function in an
i(insertion sequence): in a sequence of oplshift() calls the compiler
will first call the functions, and then use their return values in the
insertion sequence. That will invalidate the ordering of the arguments passed
to your lshift()-operators.

So, one might consider constructing another overloaded oplshift()
accepting the address of a function receiving not just the ti(ostream)
reference, but a series of other arguments as well. The problem now is that it
isn't clear how the function will receive its arguments: you can't just call
it, since that produces the abovementioned problem, and you can't just pass
its address in the insertion sequence, as you normally do with a
manipulator....

However, there is a solution, based on the use of hi(anonymous object)
anonymous objects:
    itemization(
    it() First, a class is constructed, e.g. tt(Align), whose
i(constructor) expects multiple arguments. In our example representing,
respectively, the field width and the alignment.
    it() Furthermore, we define the function:
            verb(
        ostream &operator<<(ostream &ostr, Align const &align)
            )
        so we can insert an tt(Align) object into the ostream.
    )
    Here is an example of a little program using such a em(home-made)
manipulator expecting multiple arguments:
        verbinclude(overloading/examples/manipulator.cc)
    Note that in order to insert an anonymous tt(Align) object into the
tt(ostream), the oplshift() function em(must) define a tt(Align const &)
parameter (note the tt(const) modifier).
