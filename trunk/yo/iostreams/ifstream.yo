The class ti(ifstream) is derived from the class tt(istream): it has the same
capabilities as the tt(istream) class, but can be used to i(access files) for
reading. Such files must exist.

In order to use the tt(ifstream) class in bf(C++) sources, the
    i(preprocessor directive) ti(#include <fstream>) must be given.

The following hi(ifstream constructors) constructors are available for
tt(ifstream) objects:
    itemization(
        itt(ifstream object):
            quote(This is the basic constructor. It creates
an tt(ifstream) object which may be associated with an actual file later,
using the tt(open()) member (see below).)
        itt(ifstream object(char const *name, int mode)):
            quote( This constructor can be used to associate an tt(ifstream)
object with the file named tt(name), using input mode tt(mode).  The
emi(input mode) is by default ti(ios::in). See also section ref(OUTPUTMODES)
for an overview of available file modes.

In the following example an tt(ifstream) object is opened for reading. The
file must exist:
        verb(
    ifstream in("/tmp/scratch");
        )
        )
    )
    Instead of directly associating an tt(ifstream) object with a file, the
object can be constructed first, and opened later.
    itemization(
        itht(ifstream::open())
        (void ifstream::open(char const *name, int mode)):
            quote( Having constructed an tt(ifstream) object, the member
function tt(open()) can be used to associate the tt(ifstream) object
with an actual file.)
        iti(ifstream::close()):
            quote(Conversely, it is possible to close an tt(ifstream) object
explicitly using the tt(close()) member function. The function sets the
ti(ios::fail) flag of the closed object. A file is hi(closing streams)
automatically closed when the associated tt(ifstream) object ceases to exist.)
        )
    A subtlety is the following: Assume a stream is constructed, but it is not
actually attached to a file. E.g., the statement tt(ifstream ostr) was
executed. When we now check its status through tt(good()), a non-zero (i.e.,
em(ok)) value will be returned.  The `good' status here indicates that the
stream object has been properly constructed. It doesn't mean the file is also
open. To test whether a stream is actually open, hi(testing the `open' status)
inspect hi(is_open) tt(ifstream::is_open()): If ti(true), the stream is
open. See also the example in section ref(OFSTREAM).

To illustrate reading from a binary file (see also section ref(ISTREAMREAD)),
a tt(double) value is read in binary form from a
file in the next example:
        verbinclude(iostreams/examples/readdouble.cc)
