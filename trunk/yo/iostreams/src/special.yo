Special functions are available for unformated (also called em(binary))
reading and writing of files.

For em(reading) the following member functions, that can be used with
tt(istream) objects (which includes tt(ifstream) and tt(fstream) objects)
are available:
    startit()
        itt(int istream::get()): this function returns endOfFile() or the next
available single character as an tt(int) value.
        itt(istream &istream::get(char &c)): this function reads the next
single character from the input stream into tt(c).
        itt(int istream::peek()): this function returns the next available
input character, but does not actually remove the character from the input
stream.
        itt(istream& istream::get(char *buffer, int len [, char delimiter])):
    This function reads a string from the input stream into the array starting
at tt(buffer), which should be at least tt(len) bytes long. At most tt(len -
1) characters are read into the buffer. The delimiter is a newline (tt('\n'))
character by default.nl()
    Note that the bf(delimiter is not read) by tt(get()) if the delimiter is
encountered in the input stream.nl()
    After reading the string into tt(buffer), an tt(ascii-Z) character is appended
to the string in tt(buffer) delimiter. nl()
    Note that the functions tt(eof()) and tt(fail()) (see section
ref(IOStreamConditionStates)) do em(not) return tt(true) if the delimiter was
not encountered on input. Furthermore, an tt(ascii-Z) character can be used for the
delimiter: this way strings terminating in tt(ascii-Z) characters may be read from
a (binary) file. Of course, the program reading the string should know in
advance the number of characters that are going to be read by the function.
    A small example illustrating the use of tt(get()) in combination with
tt(ascii-Z) delimiters is:
        verb(
    #include <fstream>

    int main(int argc, char **argv)
    {
        fstream
            f(argv[1], ios::in | ios::out); // r/w the file, assume this
                                            // succeeds
        f.write("hello", 6);
        f.write("hello", 6);

        f.seekg(0, ios::beg);               // reset to begin of file

        char
            buffer[20],
            c;
                                            // read the first `hello'
        cout << f.get(buffer, 100, 0).tellg() << endl;;
        f >> c;                             // read the ascii-z delim

                                            // and read the second `hello'
        cout << f.get(buffer + 6, 100, 0).tellg() << endl;;
    }
        )
        itt(istream& istream::getline (char *buffer, int len [, char
            delimiter]))
        This function operates analogously to tt(get()), but tt(delimiter) is
removed from the input if it is actually encountered. At most tt(len - 1)
bytes are written into the tt(buffer), and a trailing tt(ascii-Z) character is
appended to the string that was read. The delimiter itself is em(not) stored
in the tt(buffer). If tt(delimiter) was em(not) found (before reading tt(len)
characters or endOfFile()), tt(getline()) the tt(fail()) member function, and
possibly also tt(eof()) will return true.nl()
        itt(istream& istream::read(void *buffer, int len)): this function
reads at most tt(len) bytes from the input stream into the buffer. If
endOfFile() is encountered first, fewer bytes are read, and the
member function tt(eof()) will return tt(true). This function will normally be
used for reading em(binary) files. In the following example, an object of the
class tt(Date) is read in its binary form from a file:
        verb(
    #include <fstream>

    class Date
    {
        public:
            size_t year;
            size_t month;
            size_t day;
    };

    int main(int argc, char **argv)
    {
        ifstream f(argv[1]);
        Date d;

        f.read(&d, sizeof(Date));  // reads object in binary form.
    }
        )
        itt(int istream::gcount()): this function does not actually read from
the input stream, but returns the number of characters that were read from the
input stream during the last unformated input operation.
        itt(istream& istream::ignore ([int n [, int delimiter]])): called
without arguments, one character is skipped from the input stream. Called with
one argument, tt(n) characters are skipped. The optional second argument
specifies a delimiter: after skipping tt(n) or the tt(delimiter) character
(whichever comes first) the function returns.
        itt(istream& istream::putback (char c)): the character tt(c) is
`pushed back' into the input stream, to be read as the next
character. endOfFile() is returned if this is not allowed. One character may
always be put back.
        itt(istream& istream::unget()): an attempt is made to push back the
last character that was read.
    endit()


For em(writing) binary files the following member functions are
available. These functions can be used with tt(ostream) objects (including
tt(ofstream) and tt(fstream) objects):
    startit()
        itt(ostream& ostream::put(char c)): this function writes a single
character to the output stream.
        itt(ostream& ostream::write (void *buffer, int length)): this function
writes at most tt(len) bytes to the output stream. This function will normally
be used for writing em(binary) files.
        itt(ostream& ostream::flush()): any pending output on the output
stream is written. tt(flush()) is implied when tt(endl) is inserted into an
tt(ostream).
    endit()
