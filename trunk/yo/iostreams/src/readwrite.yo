In order to be able to read and write to a file a tt(fstream) object must be
created. To read and write to a tt(strstream) a tt(strstream) object must be
created. Again, the constructor receives the name of the file to be opened:

    center(tt(fstream inout("infile", ios::in | ios::out);))

Note the use of the tt(ios) constants tt(ios::in) and tt(ios::out), indicating
that the file must be opened both for reading and writing. Multiple mode
indicators may be used, concatenated by the binary or operator tt('|').
Alternatively, instead of tt(ios::out),
tt(ios::app) might have been used, in which case writing will always be done
at the end of the file.

Under bf(DOS)-like operating systems, which use the multiple character
tt(\r\n) sentinels to separate lines in textfiles the flag tt(ios::binary)
(or tt(ios::bin)) is
required for processing binary files to ensure that tt(\r\n) combinations are
processed as two characters.

With tt(fstream) objects, the tt(ios::out) will result in the creation
of the file, if the file doesn't exist, and if tt(ios::out) is the only
mode specification of the file. If the mode tt(ios::in) is given as well,
then the file is created only if it doesn't exist. So, we have the following
possibilities:
verb(
    -------------------------------------------------------------
                                 Specified Filemode
                    ---------------------------------------------
     File:                ios::out            ios::in | ios::out
    -------------------------------------------------------------
     exists           File is rewritten     File is used as found

    doesn't exist      File is created         File is created
    -------------------------------------------------------------
)

Once a file has been opened in read and write mode, the lshift() operator
may be used to write to the file, while the rshift() operator may be used
to read from the file. These operations may be performed in random order.
The following fragment will read a blank-delimited word from the file,
will write a string to the file, just beyond the point where the string
just read terminated, and will read another string: just beyond the location
where the string just written ended:
verb(
    ...
    fstream
        f("filename", ios::in | ios::out);
    char
        buffer[80]; // for now assume this
                    // is long enough

    f >> buffer;    // read the first word

                    // write a well known text
    f << "hello world";

    f >> buffer;    // and read again
)
Since the operators lshift() and rshift() can apparently be used with tt(fstream)
objects, you might wonder whether a series of lshift() and rshift() operators
in one statement might be possible. After all, tt(f >> buffer) should produce
a tt(fstream &), shouldn't it?

The answer is: it doesn't. The compiler casts the tt(fstream) object into
an tt(ifstream) object in combination with the extraction operator, and into an
tt(ofstream) object in combination with the insertion operator. Consequently,
a statement like
    centt(f >> buffer << "grandpa" >> buffer;)
results in a compiler error like
    centt(no match for `operator <<(class istream, char[8])')
Since the compiler complains about the tt(istream) class, the tt(fstream)
object is apparently considered an tt(ifstream) object in combination with
the extraction operator.

Of course, random insertions and extractions are hardly used. Generally,
insertions and extractions take place at specific locations in the file.
In those cases, the position where the insertion or extraction must take
place can be controlled and monitored by the tt(seekg()) and tt(tellg())
member functions.

The member function tt(tellg()) returns the current offsetposition of the
stream for which it is called.

The member function tt(seekg()) expects two arguments, the second one having a
default value:
    centt(seekg(long offset, seek_dir position = ios::beg);)
The first argument is a tt(long) offset with respect to a tt(seek_dir) postion.
The tt(seek_dir) position may be one of:
startit()
    itt(ios::beg): add tt(offset) to the begin of file position. Negative
        offsets result in an error condition, which must be cleared before
        any further operations on the file will succeed.
    itt(ios::end): add tt(offset) to the end of file position. Positive
        offsets result in the insertion of as many padding tt((char)0)
        characters as necessary to reach the intended offset.
    itt(ios::cur): add tt(offset) to the current file position. If adding
        the tt(offset) to the current position would result in a position
        before tt(ios::beg), then, again, an error condition results. If the
        position would be beyond tt(ios::end), then extra tt((char)0)
        characters are supplied.
endit()

Error conditions (see also section ref(IOStreamConditionStates)) occurring
due to, e.g., reading beyond end of file, reaching end of file, or positioning
before begin of file, can be cleared using the tt(clear()) member function.
Following tt(clear()) processing continues. E.g.,
verb(
    ...
    fstream
        f("filename", ios::in | ios::out);
    char
        buffer[80]; // for now assume this
                    // is long enough

    f.seekg(-10);   // this fails, but...
    f.clear();      // processing f continues

    f >> buffer;    // read the first word
)

tt(Strstream) objects can be given flags as well. The tt(ostrstream) object
may be constructed by the following constructor:
        centt(ostrstream text(initext, size, flags);)
    where tt(initext) is an ascii-z terminated initialization text, tt(size)
is the size of the internal buffer of the tt(strstream) object, and tt(flags)
is a set of tt(ios) flags. The last and last two arguments are
optional. If tt(size) is specified, the internal buffer will not grow
dynamically, but will be given a static size of tt(size) bytes.
