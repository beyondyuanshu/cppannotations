The class ti(ios_base) forms the foundation of all I/O operations, and
defines, among other things, the facilities for inspecting the
    i(state of I/O streams) and most i(output formatting) facilities. Every
stream class of the I/O library is, via the class ti(ios), em(derived) from
this class, and em(inherits) its capabilities.

The discussion of the class tt(ios_base) precedes the introduction of members
that can be used for actual reading from and writing to streams. But as the
tt(ios_base) class is the foundation on which all I/O in bf(C++) was built, we
introduce it as the first class of the bf(C++) I/O library.

Note, however, that as in bf(C), I/O in bf(C++) is em(not) part of the
language (although it em(is) part of the i(ANSI/ISO) standard on bf(C++)):
although it is technically possible to ignore all predefined I/O facilities,
nobody actually does so, and the I/O library represents therefore a
em(de facto) I/O standard in bf(C++). Also note that, as mentioned before,
the iostream classes do not do input and output themselves, but delegate this
to an auxiliary class: the class ti(streambuf) or its derivatives.

For the sake of completeness it is noted that it is em(not)
possible to construct an tt(ios_base) object directly. As covered by chapter
ref(INHERITANCE), classes that are derived from tt(ios_base) (like tt(ios))
may construct tt(ios_base) objects using the ti(ios_base::ios_base())
constructor.

The next class in the iostream hierarchy (see figure ref(IOCLASSESFIG)) is the
class ti(ios). Since the stream classes inherit from the class tt(ios), and
thus also from tt(ios_base), in practice the distinction between tt(ios_base)
and ti(ios) is hardly important. Therefore, facilities actually provided by
tt(ios_base) will be discussed as facilities provided by tt(ios). The reader
who is interested in the true class in which a particular facility is defined
should consult the relevant header files (e.g., ti(ios_base.h) and
ti(basic_ios.h)).
