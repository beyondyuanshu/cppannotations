In order to both i(read and write to a stream) an ti(fstream) object
must be created.  As with tt(ifstream) and tt(ofstream) objects, its
constructor receives the name of the file to be opened:
        centt(fstream inout("iofile", ios::in | ios::out);)
    Note the use of the ti(ios) constants ti(ios::in) and ti(ios::out),
indicating that the file must be opened for both reading and writing. Multiple
mode indicators may be used, concatenated by the binary or operator tt('|').
Alternatively, instead of tt(ios::out), ti(ios::app) could have been used, in
which case writing will always be done at the end of the file.

    Somehow reading and writing to a file is a bit awkward: what to do when
the file may or may not exist yet, but if it already exists it should not be
rewritten? hi(fstream: reading and writing)
    hi(reading and writing fstreams)
    I have been fighting with this problem for some time, and now I use
the following approach:
    verbinclude(iostreams/examples/existingreadwrite.cc)
    In the above example, the constructor fails when tt(fname) doesn't exist
yet. However, in that case the tt(open()) member will normally succeed since
the file is created due to the tt(ios::trunc) flag. If the file already
existed, the constructor will succeed. If the ti(ios::ate) flag would have
been specified as well with tt(rw)'s initial construction, the first
read/write action would by default have take place at endOfFile(). However,
tt(ios::ate) is not ti(ios::app), so it would then still have been possible to
repositioned tt(rw) using tt(seekg()) or tt(seekp()).

Under hi(MS-DOS) hi(MS-WINDOWS) hi(DOS) hi(WINDOWS) bf(DOS)-like operating
systems, which use the multiple character tt(\r\n) sentinels to separate lines
in i(text files) the flag ti(ios::binary) is required for
processing i(binary files) to ensure that tt(\r\n) combinations are processed
as two characters.

With tt(fstream) objects, combinations of file flags are used to make sure
that a stream is or is not (re)created empty when opened. See section
ref(OUTPUTMODES) for details.

    Once a file has been opened in read and write mode, the lshift() operator
can be used to insert information to the file, while the rshift() operator may
be used to extract information from the file. These operations may be
performed in random order.  The following fragment will read a blank-delimited
word from the file, and will then write a string to the file, just beyond the
point where the string just read terminated, followed by the reading of yet
another string just beyond the location where the string just written ended:
        verb(
    fstream f("filename", ios::in | ios::out | ios::trunc);
    string  str;

    f >> str;       // read the first word
                    // write a well known text
    f << "hello world";
    f >> str;       // and read again
        )
    Since the operators lshift() and rshift() can apparently be used with
tt(fstream) objects, you might wonder whether a series of lshift() and rshift()
operators in one statement might be possible. After all, tt(f) rshift() tt(str)
should produce an tt(fstream &), shouldn't it?

    The answer is: it doesn't. The compiler casts the tt(fstream) object into
an ti(ifstream) object in combination with the extraction operator, and into
an ti(ofstream) object in combination with the insertion
operator. Consequently, a statement like
        verb(
    f >> str << "grandpa" >> str;
        )
    results in a compiler error like
        verb(
    no match for `operator <<(class istream, char[8])'
        )
    Since the compiler complains about the tt(istream) class, the tt(fstream)
object is apparently considered an tt(ifstream) object in combination with the
extraction operator.

Of course, random insertions and extractions are hardly used. Generally,
insertions and extractions take place at specific locations in the file.
In those cases, the position where the insertion or extraction must take
place can be controlled and monitored by the ti(seekg()) and ti(tellg())
member functions (see sections ref(OSTREAMPOS) and ref(ISTREAMPOS)).

Error conditions (see section ref(IOSTATES)) occurring due to, e.g., reading
beyond end of file, reaching end of file, or positioning before begin of file,
can be cleared using the ti(clear()) member function.  Following tt(clear())
processing may continue. E.g.,
        verb(
    fstream f("filename", ios::in | ios::out | ios::trunc);
    string  str;

    f.seekg(-10);   // this fails, but...
    f.clear();      // processing f continues

    f >> str;       // read the first word
        )
    A common situation in which files are both read and written occurs in
    emi(data base) applications, where files consists of records of fixed
size, and where the location and size of pieces of information is well
known. For example, the following program may be used to add lines of text to
a (possibly existing) file, and to retrieve a certain line, based on its
order-numer from the file. Note the use of the emi(binary file) tt(index) to
retrieve the location of the first byte of a line.
        verbinclude(iostreams/examples/readwrite.cc)
    As another example of reading and writing files, consider the following
program, which also serves as an illustration of reading an i(ASCII-Z)
delimited string:
        verbinclude(iostreams/examples/asciiz.cc)

    A completely different way to both read and write to streams can be
implemented using the ti(streambuf) members of stream objects. All
considerations mentioned so far remain valid: before a read operation
following a write operation tt(seekg()) must be used, and before a write
operation following a read operation tt(seekp()) must be used. When the
stream's tt(streambuf) objects are used, either an tt(istream) is associated
with the tt(streambuf) object of another tt(ostream) object, or em(vice
versa), an tt(ostream) object is associated with the tt(streambuf) object of
another tt(istream) object. Here is the same program as before, now using
    hi(streams: associating) em(associated streams):
        verbinclude(iostreams/examples/readwrite2.cc)
    Please note:
    itemization(
    it() The streams to associate with the tt(streambuf) objects of
existing streams are not ti(ifstream) or ti(ofstream) objects (or, for that
matter, tt(istringstream) or tt(ostringstream) objects), but basic
ti(istream) and ti(ostream) objects.
    it() The tt(streambuf) object does not have to be defined in an
tt(ifstream) or ti(ofstream) object: it can be defined outside of the streams,
using constructions like:
        verb(
    filebuf fb("index", ios::in | ios::out | ios::trunc);
    istream index_in(&fb);
    ostream index_out(&fb);
        )
    it() Note that an tt(ifstream) object can be constructed using stream
modes normally used for writing to files. Conversely, tt(ofstream) objects can
be constructed using stream modes normally used for reading from files.
    it() If tt(istream) and tt(ostreams) are associated through a common
tt(streambuf), then the read and write pointers (should) point to the same
locations: they are tightly coupled.
    it() The advantage of using a separate tt(streambuf) over a predefined
tt(fstream) object is (of course) that it opens the possibility of using
tt(stream) objects with specialized tt(streambuf) objects. These tt(streambuf)
objects may then specifically be constructed to interface particular
devices. Elaborating this is left as an i(exercise) to the reader.
    )
