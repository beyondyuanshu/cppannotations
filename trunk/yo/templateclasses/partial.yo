    In the previous section we've seen that it is possible to design template
class specializations. It was shown that both class template members and
complete class templates could be specialized. Furthermore, the
specializations we've seen were specializing template type parameters.

    In this section we'll introduce a variant of these specializations, both
in number and types of template parameters that are specialized.
em(Partial specializations) may be defined for class templates having
        hi(partial specialization)
        hi(class template: partial specialization)
    multiple template parameters. With partial specializations a subset (any
subset) of template type parameters are given specific values.

    Having discussed specializations of template type parameters in
the previous section, we'll discuss specializations of non-type parameters in
the current section. Partial specializations of template non-type parameters
will be illustrated using some simple concepts defined in matrix algebra, a
branch of linear algebra.

    A matrix is commonly thought of as consisting of a table of a certain
number of rows and columns, filled with numbers. Immediately we recognize an
opening for using templates: the numbers might be plain tt(double) values, but
they could also very well be complex numbers, for which our
    emi(complex container) (cf. section ref(COMPLEX)) might prove
useful. Consequently, our class template should be given a tt(DataType)
template type parameter, for which a ordinary class can be specified when a
matrix is constructed. Some simple matrices, using tt(double) values, are:
        verb(
    1   0   0           An identity matrix,
    0   1   0           a 3 x 3 matrix.
    0   0   1

    1.2  0    0    0    A rectangular matrix,
    0.5  3.5  18  23    a 2 x 4 matrix.

    1   2   4   8       A matrix of one row,
                        a 1 x 4 matrix, also known as a
                        `row vector' of 4 elements.
                        (column vectors are analogously defined)
        )
    Since matrices consist of a specific number of rows and columns (the
em(dimensions) of the matrix), which normally do not change when using
matrices, we might consider specifying their values as template non-type
parameters. Since the tt(DataType = double) selection will be used in the
majority of cases, tt(double) can be selected as the template's default
type. Since it's having a sensible default, the tt(DataType) template type
parameter is put last in the template type parameter list. So, our template
class tt(Matrix) starts off as follows:
        verb(
    template <size_t Rows, size_t Columns, typename DataType = double>
    class Matrix
    ...
        )

    Various operations are defined on matrices. They may, for example be
added, subtracted or multiplied. We will not focus on these operations
here. Rather, we'll concentrate on a simple operation: computing marginals and
sums. The row marginals are obtained by computing, for each row, the sum of
all its elements, putting these tt(Rows) sum values in corresponding elements
of a column vector of tt(Rows) elements. Analogously, column marginals are
obtained by computing, for each column, the sum of all its elements, putting
these tt(Columns) sum values in corresponding elements of a row vector of
tt(Columns) elements. Finally, the sum of the elements of a matrix can be
computed. This sum is of course equal to the sum of the elements of its
marginals. The following example shows a matrix, its marginals, and its sum:
        verb(
                matrix:         row
                                marginals:

                1   2   3        6
                4   5   6       15

    column      5   7   9       21  (sum)
    marginals
        )
    So, what do we want our class template to offer?
    itemization(
    it() It needs a place to store its matrix elements. This can be defined as
an array of `tt(Rows)' rows each containing `tt(Columns)' elements of type
tt(DataType). It can be an array, rather than a pointer, since the matrix'
dimensions are known em(a priori). Since a vector of tt(Columns) elements (a
em(row) of the matrix), as well as a vector of tt(Row) elements (a em(column)
of the matrix) is often used, em(typedefs) could be used by the class. The
class interface's initial section therefore contains:
        verbinsert(HEAD)(templateclasses/examples/matrix.h)
    it() It should offer constructors: a default constructor and, for example,
a constructor initializing the matrix from a stream. No copy constructor is
required, since the default copy constructor performs its task
properly. Analogously, no overloaded assignment operator or destructor is
required. Here are the constructors, defined in the public section:
        verbinsert(CONSTRUCTORS)(templateclasses/examples/matrix.h)
    it() The class's tt(operator[]()) member (and its tt(const) variant) only
handles the first index, returning a reference to a complete
tt(MatrixRow). How to handle the retrieval of elements in a tt(MatrixRow) will
be covered shortly. To keep the example simple, no array bound check has been
implemented:
        verbinsert(OPERATOR=)(templateclasses/examples/matrix.h)
    it() Now we get to the interesting parts: computing marginals and the sum
of all elements in a tt(Matrix). Considering that marginals are vectors,
either a tt(MatrixRow), containing the column marginals, a tt(MatrixColumn),
containing the row marginals, or a single value, either computed as
the sum of a vector of marginals, or as the value of a tt(1 x 1) matrix,
initialized from a generic tt(Matrix), we can now construct em(partial
specializations) to handle tt(MatrixRow) and tt(MatrixColumn) objects,
and a partial specialization handling tt(1 x 1) matrices. Since we're about
to define these specializations, we can use them when computing
marginals and the matrix' sum of all elements. Here are the implementations of
these members:
        verbinsert(MARGINALS)(templateclasses/examples/matrix.h)
    )

    Class template em(partial specializations) may be defined for any (subset)
        hi(partial specialization)
        hi(class template: partial specialization)
    of template parameters. They can be defined for template type parameters
and for template non-type parameters alike. Our first partial specialization
defines the special case where we construct a row of a generic tt(Matrix),
specifically aiming at (but not restricted to) the construction of column
marginals. Here is how such a partial specialization is constructed:
    itemization(
    it() The partial specialization starts by defining all template type
parameters which are em(not) specialized in the partial specialization. This
partial specialization template announcement cannot specify any defaults (like
tt(DataType = double)), since the defaults have already been specified by the
generic class template definition. Furthermore, the specialization em(must)
follow the definition of the generic class template definition, or the
compiler will complain that it doesn't know what class is being
specialized. Following the template announcement, the class interface
starts. Since it's a class template (partial) specialization, the class name
is followed by a template type parameter list specifying ordinary values or
types for all template parameters specified in this specialization, and using
the template's generic (non-)type names for the remaining template
parameters. In the tt(MatrixRow) specialization tt(Rows) is specified as 1,
since we're talking here about one single row. Both tt(Columns) and
tt(DataType) remain to be specified. So, the tt(MatrixRow) partial
specialization starts as follows:
        verbinsert(MATRIXROW)(templateclasses/examples/matrix.h)
    it() A tt(MatrixRow) contains the data of a single row. So it needs a
data member storing tt(Columns) values of type tt(DataType). Since tt(Columns)
is a constant value, the tt(d_row) data member can be defined as an array:
        verbinsert(ROWDATA)(templateclasses/examples/matrix.h)
    it() The constructors require some attention. The default constructor is
simple. It merely initializes the tt(MatrixRow)'s data elements, using
tt(DataType)'s default constructor:
        verbinsert(ROWCONS1)(templateclasses/examples/matrix.h)
    However, we also need a constructor initializing a tt(MatrixRow) object
with the column marginals of a generic tt(Matrix) object. This requires us to
provide the constructor with a non-specialized tt(Matrix) parameter. In cases
like this, the i(rule of thumb) is to define a member template allowing us to
keep the general nature of the parameter. Since the generic tt(Matrix)
template requires three template parameters, two of which are already provided
by the template specialization, the third parameter must be specified in the
member template's template announcement. Since this parameter refers to the
generic matrix' number of rows, let's simply call it tt(Rows). Here then, is
the definition of the second constructor, initializing the tt(MatrixRow)'s
data with the column marginals of a generic tt(Matrix) object:
        verbinsert(ROWCONS2)(templateclasses/examples/matrix.h)
    Note the way the constructor's parameter is defined: it's a reference to a
tt(Matrix) template, using the additional tt(Row) template parameter as well
as the template parameters of the partial specialization itself.
    it() We don't really require additional members to satisfy our current
needs. To access the data elements of the tt(MatrixRow) an overloaded
tt(operator[]()) is of course useful. Again, the tt(const) variant can be
implemented like the non-tt(const) variant. Here is its implementation:
        verbinsert(ROWOPERATOR=)(templateclasses/examples/matrix.h)
    )
    Now that we have defined the generic tt(Matrix) class as well as the
partial specialization defining a single row, the compiler will select the
row's specialization whenever a tt(Matrix) is defined using tt(Row = 1). For
example:
        verb(
    Matrix<4, 6> matrix;        // generic Matrix template is used
    Matrix<1, 6> row;           // partial specialization is used
        )

    The partial specialization for a tt(MatrixColumn) is constructed
similarly. Let's present its highlights (the full tt(Matrix) class template
definition as well as all its specializations are provided in the
tt(cplusplus.yo.zip) archive (at url(ftp.rug.nl)
(ftp:://ftp.rug.nl/contrib/frank/documents/annotations/)) in the
file tt(yo/templateclasses/examples/matrix.h)):
    itemization(
    it() The class template partial specialization again starts with a
template announcement. The class definition itself now specifies a fixed
value for the second (generic) template parameter, illustrating that we can
construct partial specializations for every single template parameter; not
just the first or the last:
        verbinsert(MATRIXCOLUMN)(templateclasses/examples/matrix.h)
    it() Its constructors are implemented completely analogously to the way
the tt(MatrixRow) constructors were implemented. Their implementations are
left as an exercise to the reader (and they can be found in tt(matrix.h)).
    it() An additional member tt(sum()) is defined to compute the sum of the
elements of a tt(MatrixColumn) vector. It's implementation is simply realized
using the tt(accumulate()) generic algorithm:
        verbinsert(SUMCOLUMN)(templateclasses/examples/matrix.h)
    )

    The reader might wonder what happens if we specify the following matrix:
        centt(Matrix<1, 1> cell;)
    Is this a tt(MatrixRow) or a tt(MatrixColumn) specialization? The answer
is: neither. It's i(ambiguous), precisely because em(both) the columns em(and)
the rows could be used with a (different) template partial specialization. If
such a tt(Matrix) is actually required, yet another specialized template must
be designed. Since this template specialization can be useful to
obtain the sum of the elements of a tt(Matrix), it's covered here as well:
    itemization(
    it() This class template partial specialization also needs a template
announcement, this time only specifying tt(DataType). The class definition
specifies two fixed values, using 1 for both the number of rows and the number
of columns:
        verbinsert(MATRIX1X1)(templateclasses/examples/matrix.h)
    it() The specialization defines the usual batch of constructors. Again,
constructors expecting a more generic tt(Matrix) type are implemented as
member templates. For example:
        verbinsert(1X1CONS)(templateclasses/examples/matrix.h)
    it() Since tt(Matrix<1, 1>) is basically a wrapper around a tt(DataType)
value, we need members to access that latter value. A type conversion
operator might be usefull, but we'll also need a tt(get()) member to obtain
the value if the conversion operator isn't used by the compiler (which
happens when the compiler is given a choice, see section
ref(ConversionOperators)). Here are the accessors (leaving out their tt(const)
variants):
        verbinsert(ACCESSORS)(templateclasses/examples/matrix.h)
    )
    The following tt(main()) function shows how the tt(Matrix) class template
and its partial specializations can be used:
    verbinclude(templateclasses/examples/matrix.cc)
