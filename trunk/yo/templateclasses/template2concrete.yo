When an existing class template is used as a base class for deriving an
ordinary class, the class template parameters are specified when defining the
derived class's interface.  If in a certain context an existing class template
lacks a particular functionality, then it may be useful to derive a ordinary
class from a class template. For example, although the class tt(map) can
easily be used in combination with the tt(find_if()) generic algorithm
(section ref(FINDIF)) to locate a particular element, it requires the
construction of a class and at least two additional function objects of that
class. If this is considered too much overhead in a particular context,
extending a class template with some tailor-made functionality might be
considered.

A program executing commands entered at the keyboard might accept all unique
initial abbreviations of the commands it defines. E.g., the command tt(list)
might be entered as tt(l, li, lis) or tt(list). By deriving a class
tt(Handler) from
        centt(map<string, void (Handler::*)(string const &cmd)>)
    and defining a tt(process(string const &cmd)) to do the actual command
processing, the program might simply execute the following tt(main())
function:
        verbinsert(MAIN)(templateclasses/examples/template2concrete.cc)
    The class tt(Handler) itself is derived from a complex tt(map), in which
the map's values are pointers to tt(Handler)'s member functions, expecting the
command line entered by the user. Here are tt(Handler)'s characteristics:
    itemization(
    it() The class is derived from a tt(std::map), expecting the command
associated with each command-processing member as its keys. Since
tt(Handler) uses the map merely to define associations between
        hi(inheritance: private derivation)
the commands and the processing member functions, we use private derivation
here:
        verbinsert(HEAD)(templateclasses/examples/template2concrete.cc)
    it() The actual association can be defined using static private data
members: tt(s_cmds) is an array of tt(Handler::value_type) values, and
tt(s_cmds_end) is a constant pointer pointing beyond the array's last element:
        verbinsert(STATIC)(templateclasses/examples/template2concrete.cc)
    it() The constructor simply initializes the map from these two static data
members. It could be implemented inline:
        verbinsert(CONS)(templateclasses/examples/template2concrete.cc)
    it() The member tt(process()) iterates along the map's elements. Once the
first word on the command line matches the initial characters of the command,
the corresponding command is executed. If no such command is found, an error
message is issued:
        verbinsert(PROCESS)(templateclasses/examples/template2concrete.cc)
    )
