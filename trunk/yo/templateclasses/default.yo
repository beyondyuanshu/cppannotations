    Different from function templates, template parameters of template
classes may be given default values.
        hi(class template: default parameter values)
    This holds true both for template type- and template non-type
parameters. If a class template is instantiated without specifying arguments
for its template parameters, and if default template parameter values were
defined, then the defaults are used. When defining such defaults keep in mind
that the defaults should be suitable for the majority of instantiations of the
class. E.g., for the class template tt(FBB::auto_ptr) the template's type
parameter list could have been altered by specifying tt(int) as its default
type:
        centt(template <typename Data = int>)
    Even though default arguments can be specified, the compiler must still be
informed that object definitions refer to templates. So, when instantiating
class template objects for which default parameter values have been defined
the type specifications may be omitted, but the angle brackets must
remain. So, assuming a default type for the tt(FBB::auto_ptr) class, an object
of that class may be defined as:
        centt(FBB::auto_ptr<> intAutoPtr;)
    No defaults must be specified for template members defined outside of
their class interface. Function templates, even member function templates,
cannot specify default parameter values. So, the definition of, e.g., the
tt(release()) member will always begin with the same tt(template)
specification:
        centt(template <typename Data>)

    When a class template uses multiple template parameters, all may be given
default values. However, like default function arguments, once a default value
is used, all remaining parameters must also use their default values. A
template type specification list may not start with a comma, nor may it
contain multiple consecutive commas.
