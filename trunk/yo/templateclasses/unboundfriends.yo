    When a friend is declared as an em(unbound) friend, it merely declares an
existing template to be its friend, no matter how it is instantiated. This may
be useful in situations where the friend should be able to
instantiate objects of class templates declaring the friend, allowing the
friend to access the instantiated object's private members.
Again, functions, classes and member functions may be declared as unbound
friends.

Here are  the syntactical conventions  declaring unbound friends:
    itemization(
        it() Declaring an unbound function template as a friend: any
instantiation of the function template may instantiate objects of the template
class and may access its private members. Assume the following
function template has been defined
        verb(
    template <typename Iterator, typename Class, typename Data>
    Class &ForEach(Iterator begin, Iterator end, Class &object,
                        void (Class::*member)(Data &));
        )

    This function template can be declared as an unbound friend in the
following class template tt(Vector2):
        verb(
    template <typename Type>
    class Vector2: public std::vector<std::vector<Type> >
    {
        template <typename Iterator, typename Class, typename Data>
        friend Class &ForEach(Iterator begin, Iterator end, Class &object,
                    void (Class::*member)(Data &));
        ...
    };
        )
    If the function template is defined inside some namespace, the namespace
must be mentioned as well. E.g., assuming that tt(ForEach()) is defined in the
namespace tt(FBB) its friend declaration becomes:
        verb(
    template <typename Iterator, typename Class, typename Data>
    friend Class &FBB::ForEach(Iterator begin, Iterator end, Class &object,
                    void (Class::*member)(Data &));
        )
    The following example illustrates the use of an unbound friend. The class
tt(Vector2) stores vectors of elements of template type parameter
tt(Type). Its tt(process()) member uses tt(ForEach()) to have its private
tt(rows()) member called, which in turn uses tt(ForEach()) to call its private
tt(columns()) member. Consequently, tt(Vector2) uses two instantiations of
tt(ForEach()), and therefore an unbound friend is appropriate here. It is
assumed that tt(Type) class objects can be inserted into tt(ostream) objects
(the definition of the tt(ForEach()) function template can be found in the
tt(cplusplus.yo.zip) archive at the tt(ftp.rug.nl) ftp-server). Here is the
program:
        verbinsert(VECTOR2)(concrete/examples/foreachdemo.cc)
    it() Analogously, a full class template may be declared as a friend. This
allows all instantiations of the friend's member functions to instantiate the
template declaring the friend class. In this case, the class declaring the
friend should offer useful functionality to different instantiations (i.e.,
using different arguments for its template parameters) of its friend
class. The syntactical convention is comparable to the convention used when
declaring an unbound friend function template:
        verb(
    template <typename Type>
    class PtrVector
    {
        template <typename Iterator, typename Class>
        friend class Wrapper;      // unbound friend class
    };
        )
    All members of the class template tt(Wrapper) may now instantiate
tt(PtrVector)s using any actual type for its tt(Type) template parameter, at
the same time allowing tt(Wrapper)'s instantiation to access all of
tt(PtrVector)'s private members.
    it() When only some members of a class template need access to the private
members of another class template (e.g., the other class template has private
constructors, and only some members of the first class template
need to instantiate objects of the second class template), then the latter
class template may declare only those members of the former class template
requiring access to its private members as its friends. Again, the friend
class's interface may be left unspecified. However, the compiler must be
informed that the friend member's class is indeed a class. A forward
declaration of that class must therefore be given as well. In the following
example tt(PtrVector) declares tt(Wrapper::begin()) as its friend. Note the
forward declaration of the class tt(Wrapper):
        verb(
    template <typename Iterator>
    class Wrapper;

    template <typename Type>
    class PtrVector
    {
        template <typename Iterator> friend
            PtrVector<Type> Wrapper<Iterator>::begin(Iterator const &t1);
        ...
    };
        )
    )
