In section ref(NAMERESFUN) the distinction between code depending on template
parameters and code not depending on template parameters was introduced.
The same distinction also holds true when class templates are defined and
used.

    Code that does not depend on template parameters is verified by the
compiler when the template is defined. E.g., if a member function in a
class template uses a ti(qsort()) function, then tt(qsort()) does not depend
on a template parameter. Consequently, tt(qsort()) must be known to the
compiler when it encounters the tt(qsort()) function call. In practice this
implies that ti(cstdlib) or ti(stdlib.h) must have been processed by the
compiler before it will be able to process the class template definition.

    On the other hand, if a template defines a tt(<typename Type>) template
type parameter, which is the return type of some template member function,
e.g.,
        centt(Type member() ...)
    then we distinguish the following situations where the compiler encounters
tt(member()) or the class to which tt(member()) belongs:
    itemization(
    it() At the location in the source where class template objects are
defined (called the
        emi(point of instantiation) of the class template object),
    the compiler will have read the class template definition, performing a
basic check for syntactical correctness of member functions like
tt(member()). So, it won't accept a definition or declaration like tt(Type
&&member()), because bf(C++) does not support functions returning references
to references. Furthermore, it will check the existence of the actual typename
that is used for instantiating the object. This typename must be known to the
compiler at the object's point of instantiation.
    it() At the location in the source where i(template member functions) are
used (which is called the template member function's point of instantiation),
the tt(Type) parameter must of course still be known, and tt(member())'s
statements that depend on the tt(Type) template parameter are now checked for
syntactical correctness. For example, if tt(member()) contains a statement
like
        centt(Type tmp(Type(), 15);)
    then this is in principle a syntactically valid statement. However, when
tt(Type = int) and tt(member()) is called, its instantiation will fail,
because tt(int) does not have a constructor expecting two tt(int)
arguments. Note that this is em(not) a problem when the compiler instantiates
an object of the class containing tt(member()): at the point of instantiation
of the object its tt(member()) member function is not instantiated, and so the
invalid tt(int) construction remains undetected.
    )
