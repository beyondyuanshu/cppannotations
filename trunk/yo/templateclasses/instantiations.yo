Template hi(class template: instantiation) classes are instantiated when an
object of a class template is defined. When a class template object is
defined or declared, the template parameters must explicitly be specified.

    Template parameters are em(also) specified when a class template defines
default template parameter values, albeit that in that case the compiler will
provide the defaults (cf. section ref(PARTIAL) where tt(double) is used as the
default type to be used with the template's tt(DataType) parameter).  The
actual values or types of template parameters are
    hi(class template: deducing parameters) em(never) deduced, as happens with
function templates: to define a tt(Matrix) of elements that are complex
values, the following construction is used:
        centt(Matrix<3, 5, std::complex> complexMatrix;)
    while the following construction defines a matrix of elements that are
tt(double) values, with the compiler providing the (default) type tt(double):
        centt(Matrix<3, 5> doubleMatrix;)

    A class template object may be em(declared) using the keyword ti(extern).
        hi(class template: declaring objects)
    For example, the following construction is used to em(declare) the matrix
tt(complexMatrix):
        centt(extern Matrix<3, 5, std::complex> complexMatrix;)

        hi(class template: declaration)
        hi(reference: to class template)
        hi(pointer: to class template)
        hi(class template: reference to)
        hi(class template: pointer to)
    A class template declaration is sufficient if the compiler encounters
function declarations of functions having return values or parameters which
are class template objects, pointers or references. The following little
source file may be compiled, although the compiler hasn't seen the definition
of the tt(Matrix) class template.  Note that generic classes as well as
(partial) specializations may be declared. Furthermore, note that a function
expecting or returning a class template object, reference, or parameter itself
automatically becomes a function template. This is necessary to allow the
compiler to tailor the function to the types of various actual arguments that
may be passed to the function:
        verbinclude(templateclasses/examples/matrixdecl.cc)

    When class templates are used they have to be processed by the compiler
first. So, template member functions must be known to the compiler when the
template is instantiated.  This does not mean that all members of a template
class are instantiated when a class template object is defined.
        hi(class template: member instantiation)
    The compiler will only instantiate those members that are actually
used. This is illustrated by the following simple class tt(Demo), having two
constructors and two members. When we create a tt(main()) function in which
one constructor is used and one member is called, we can make a note of the
sizes of the resulting object file and executable program. Next the class
definition is modified such that the unused constructor and member are
commented out. Again we compile and link the tt(main()) function and the
resulting sizes are identical to the sizes obtained earlier (on my computer,
using tt(g++) version 4.1.2) these sizes are 3904 bytes (after
stripping). There are other ways to illustrate the point that only members
that are used are instantiated, like using the ti(nm) program, showing the
symbolic contents of object files. Using programs like tt(nm) will yield the
same conclusion: em(only template member functions that are actually used are
initialized). Here is an example of the class template tt(Demo) used for this
little experiment. In tt(main()) only the first constructor and the first
member function are called and thus only these members were instantiated:
        verbinclude(templateclasses/examples/instantiations.cc)
