    In section ref(ITERATORS) the i(iterators) used with i(generic algorithms)
were introduced. We've seen that several types of iterators were
distinguished: i(InputIterators), i(ForwardIterators), i(OutputIterators),
i(BidirectionalIterators) and i(RandomAccessIterators).

    In section ref(ITERATORS) the i(characteristics of iterators) were
introduced: all iterators should support an increment operation, a dereference
operation and a comparison for (in)equality.

    However, when iterators must be used in the context of generic algorithms
they must meet additional requirements. This is caused by the fact that
generic algorithms check the types of the iterators they receive. Simple
pointers are usually accepted, but if an iterator-object is used it must be
able to specify the kind of iterator it represents.

    To ensure that an object of a class is interpreted as a particular type of
iterator, the class must be derived from the ti(class iterator). The
particular type of iterator is defined by the class template's em(first)
parameter, and the particular data type to which the iterator points is
defined by the class template's em(second) parameter.  Before a class may be
inherited from the class tt(iterator), the following header file must have
        hi(#include <iterator>)
been included:
        centt(#include <iterator>)
    The particular type of iterator that is implemented by the derived class
is specified using a so-called emi(iterator_tag), provided as the
first template argument of the class tt(iterator). For the five basic iterator
types, these tags are:
    itemization(
    it() ti(std::input_iterator_tag). This tag defines an i(InputIterator).
        Iterators of this type allow reading operations, iterating from
the first to the last element of the series to which the iterator refers.
    it() ti(std::output_iterator_tag). This tag defines an i(OutputIterator).
        Iterators of this type allow for assignment operations, iterating from
the first to the last element of the series to which the iterator refers.
    it() ti(std::forward_iterator_tag). This tag defines a
        tt(ForwardIterator).
        Iterators of this type allow reading em(and) assignment
operations, iterating from the first to the last element of the series to
which the iterator refers.
    it() ti(std::bidirectional_iterator_tag). This tag defines a
        i(BidirectionalIterator). Iterators of this type allow reading
em(and) assignment operations, iterating step by step, possibly in alternating
directions, over all elements of the series to which the iterator refers.
    it() ti(std::random_access_iterator_tag). This tag defines a
    i(RandomAccessIterator).  Iterators of this type allow reading em(and)
assignment operations, iterating, possibly in alternating directions, over all
elements of the series to which the iterator refers, using any available
(random) stepsize.
    )
    Each emi(iterator tag) assumes that a certain set of operators is
available. The em(RandomAccessIterator) is the most complex of iterators, as
it implies all other iterators.

    Note that iterators are always defined over a certain range, e.g.,
rangett(begin, end). Increment and decrement operations may result in
undefined behavior of the iterator if the resulting iterator value would refer
to a location outside of this range.

    Often, iterators only access the elements of the series to which they
refer. Internally, an iterator may use an ordinary pointer, but it is hardly
ever necessary for the iterator to allocate its own memory. Therefore, as the
overloaded assignment operator and the copy constructor do not have to
allocate any memory, the em(default implementation) of the overloaded
assignment operator and of the copy constructor is usually sufficient. I.e.,
usually these members do not have to be implemented at all. As a consequence
there is usually also no em(destructor).

    Most classes offering members returning iterators do so by having members
constructing the required iterator, which is thereupon returned as an object
by these member functions. As the em(caller) of these member functions only
has to em(use) or sometimes em(copy) the returned iterator objects, there is
normally no need to provide any publicly available constructors, except for
the copy constructor. Therefore these constructors may usually be defined as
em(private) or em(protected) members. To allow an outer class to create
iterator objects, the iterator class will declare the outer class as its
em(friend).

    In the following sections, the construction of a em(RandomAccessIterator),
the most complex of all iterators, and the construction of a em(reverse
RandomAccessIterator) is discussed. The container class for which a random
access iterator must be developed may actually store its data elements in many
different ways, e.g., using various containers or using pointers to pointers.
Therefore it is difficult to construct a template iterator class which is
suitable for a large variety of ordinary (container) classes.

    In the following sections, the available tt(std::iterator) class will be
used to construct an inner class representing a random access iterator. This
approach clearly shows how to construct an iterator class. The reader may
either follow this approach when constructing iterator classes in other
contexts, or a full template iterator class can be designed. An example of
such a template iterator class is provided in section ref(CONCRETEITER).

The construction of the random access iterator as shown in the next sections
aims at the realization of an iterator reaching the elements of a series of
elements only accessible through pointers. The iterator class is designed as
an inner class of a class derived from a vector of string pointers.
