In the previous section we stated that tt(friends) can be considered
    i(member functions) of a class, albeit that the characteristics of the
function prevents us from actually defining the function as a member
function. In this section we will extend this line of reasoning a little
further.

If we conceptually consider friend functions to be member functions, we should
be able to design a true member function that performs the same tasks as our
tt(friend) function. For example, we could construct a function that inserts a
tt(PersonData) object into an tt(ostream):
        verb(
    ostream &PersonData::insertor(ostream &str) const
    {
        for (size_t idx = 0; idx < d_n; idx++)
            str << d_person[idx] << endl;
        return str;
    }
        )
    This member function can be used by a tt(PersonData) object to insert
that object into the tt(ostream str):
        verb(
    PersonData pd;

    cout << "The Person-information in the PersonData object is:\n";
    pd.insertor(str);
    cout << "========\n";
        )
    Realizing that tt(insertor()) does the same thing as the overloaded
insertion operator, earlier defined as a tt(friend), we could simply call the
tt(insertor()) member in the code of the tt(friend) oplshift() function. Now
this oplshift() function needs em(only one statement): it calls
tt(insertor()). Consequently:
    itemization(
    it() The tt(insertor()) function may be hidden in the class by making it
tt(private), as there is not need for it to be called elsewhere
    it() The oplshift() may be constructed as em(inline) member, as it
contains but one statement. However, this is deprecated since it contaminates
class interfaces with implementations. The overloaded oplshift() member should
be implemented below the class interface:
    )
    Thus, the relevant section of the class interface of tt(PersonData)
becomes:
        verb(
    class PersonData
    {
        friend ostream &operator<<(ostream &str, PersonData const &pd);

        private:
            ostream &insertor(ostream &str) const;
    };

    inline std::ostream &operator<<(std::ostream &str, PersonData const &pd)
    {
        return pd.insertor(str);
    }
        )
    The above example illustrates the final step in the development of
tt(friend) functions. It allows us to formulate the following principle:
    quote(
    Although tt(friend) functions have access to private members of a
class, this characteristic should not be used indiscriminately, as it results
in a severe breach of the principle of i(encapsulation), thereby making
non-class functions dependent on the implementation of the data in a class.

    Instead, if the task a tt(friend) function performs, can be implemented by
a true member function, it can be argued that a tt(friend) is merely a
syntactical synonym or alias for this member function.

    The interpretation of a  hi(friend function: synonym for a member)
tt(friend) function as a synonym for a member function is made concrete by
constructing the tt(friend) function as an emi(inline) function.

    As a principle we therefore state that tt(friend) functions should be
avoided, unless they can be constructed as inline functions, having only one
statement, in which an appropriate private member function is called.
    )
    Using this principle, we ascertain that all code that has access to the
private data of a class remains confined to the class itself. This even holds
true for tt(friend) functions, as they are defined as simple inline functions.
