Consider tt(string)'s member tt(insert). tt(String::insert) has several
overloaded implementations. It can be used to insert text (completely or
partially) provided in a tt(string) or in a tt(char const *) argument; to
insert single characters a specified number of times; iterators can be used to
specify the range of characters to be inserted; etc., etc.. All in,
tt(string) offers five overloaded tt(insert) members.

Assume the existence of a class tt(Inserter) that is used to insert
information into all kinds of objects. Such a class could have a tt(string)
data member into which information can be inserted. tt(Inserter)'s interface
only partially has to copy tt(string)'s interface to realize this: only
tt(string::insert)'s interfaces must be duplicated. These duplicating
interfaces often contain one statement (calling the appropriate member
function of the object's data member) and are for this reason often
implemented in-line. These wrapper functions merely emi(forward) their
parameters to the appropriate member function of the object's data member.

Factory functions also frequently forward their parameters to the constructors
of objects that they return.

Before the C++0x standard the interfaces of overloaded functions needed to
be duplicated by the forwarding entity: tt(Inserter) needed to duplicate the
interfaces of all five tt(string::insert) members; a factory function needed
to duplicate the interfaces of the constructors of the class of the objects it
returned.

The C++0x standard simplifies and generalizes forwarding of parameters by
offering emi(perfect forwarding), implemented through rvalue references and
variadic templates. With perfect forwarding the arguments passed to functions
are `perfectly forwarded' to nested functions. Forwarding is called
em(perfect) as the arguments are forwarded in a type-safe way. To use perfect
forwarding nested functions must define parameter lists matching the
forwarding parameters both in types and number.

Perfect forwarding is easily implemented:
    itemization(
    it() The forwarding function is defined as a variadic template;
    it() The forwarding function's parameter list is an
        hi(parameter pack: rvalue reference)
        em(rvalue reference parameter pack) (e.g., tt(Params && ... params));
    itht(forward)(std::forward) is used to forward the forwarding function's
        arguments to the nested function, keeping track of their types and
        number. Before using tt(forward) the tthi(utility) header file must
        have been included. The nested function is then called using this
        stanza for its arguments: tt(std::forward<Params>(params) ...).
    )

In the following example perfect forwarding is used to implement
tt(Inserter::insert). The tt(insert) function that's actually called now
depends on the types and number of arguments that are passed to
tt(Inserter::insert):
        verb(
    class Inserter
    {
        std::string d_str;  // somehow initialized
        public:
                            // constructors not implemented,
                            // but see below
            Inserter();
            Inserter(std::string const &str);
            Inserter(Inserter const &other);
            Inserter(Inserter const &&other);

            template<typename ... Params>
            void insert(Params && ... params)
            {
                d_str.insert(std::forward<Params>(params) ...);
            }
    };
        )

A factory function returning a tt(Inserter) can also easily be implemented
using perfect forwarding. Rather than defining four overloaded factory
functions a single one now suffices. By providing the factory function with an
additional template type parameter specifying the class of the object to
construct the factory function is turned into a completely general factory
function:
        verb(
    template <typename Class, typename ... Params>
    Class factory(Params && ... params)
    {
        return Class(std::forward<Params>(params) ...);
    }
        )
Here are some examples showing its use:
        verb(
    Inserter inserter(factory<Inserter>("hello"));
    string delimiter(factory<string>(10, '='));
    Inserter copy(factory<Inserter>(inserter));
        )

The function tt(std::forward) is provided by the  standard library. It
performs no magic, but merely returns tt(params) as an nameless object. That
way it acts like tt(std::move) that also removes the name from an object,
returning it as a nameless object. The unpack operator has nothing to do with
the use of tt(forward) but merely tells the compiler to apply tt(forward) to
each of the arguments in turn. Thus it behaves similarly to bf(C)'s ellipsis
operator used by variadic functions.

Perfect forwarding was introduced in section ref(CONTRACTIONS): a template
function defining a tt(Type &&param), with tt(Type) being a template type
parameter will convert tt(Type &&) to tt(Tp &) if the function is called with
an argument of type tt(Tp &). Otherwise it will bind tt(Type) to tt(Tp),
with tt(param) being defined as  tt(Tp &&param). As a result an em(lvalue)
argument will bind to an lvalue-type (tt(Tp &)), while an em(rvalue) argument
will bind to an rvalue-type (tt(Tp &&)).

The function tt(std::forward) merely passes the argument (and its type) on to
the called function or object. Here is its simplified implementation:
        verb(
    typedef <type T>
    T &&forward(T &&a)
    {
        return a;
    }
        )
    Since tt(T &&) turns into an lvalue reference when tt(forward) is called
with an lvalue (or lvalue reference) and remains an rvalue reference if
tt(forward) is called with an rvalue reference and since tt(forward) (like
tt(std::move)) anonymizes the variable passed as argument to tt(forward) the
argument value is forwarded while keeping its type
from the function's parameter to the called function's argument. This is
called em(perfect forwarding) as the called function will only be called if
the types of the arguments used when calling the `outer' function (e.g.,
tt(factory)) exactly match the types of the parameters of the called function
(e.g., tt(Class)'s constructor). Perfect forwarding therefore is a tool to
uphold type safety.

    A cosmetic improvement to tt(forward) forces users of tt(forward) to
specify the type to use rather than to have the compiler deduct the type as a
result of the function template parameter type deduction's process. This is
realized by a small support struct template:
        verb(
    template <typename T>
    struct identity
    {
        typedef T type;
    };
        )
    This struct merely defines tt(identity::type) as tt(T), but as it is a
struct it must be specified explicitly. It cannot be determined from the
function's argument itself. The subtle modification to the above
implementation of tt(forward) thus becomes (cf. section ref(DISTINGUISH) for
an explanation of the use of tt(typename)):
        verb(
    typedef <type T>
    T &&forward(typename identity<T>::type&& a)
    {
        return a;
    }
        )
    Now tt(forward) must explicitly state the tt(a)'s plain type, as in:
        verb(
    std::forward<Params>(params)
        )

    Using the tt(std::forward) function and the rvalue reference specification
is not restricted to the context of parameter packs. Because of the special
way rvalue references to template type parameters are treated (cf. section
ref(CONTRACTIONS)) they can profitably be used to forward individual function
    hi(forward: parameters)
 parameters as well. Here is an example showing how an argument to a function
can be forwarded from a template to a function that is itself passed to the
template as a pointer to a (unspecified) function:
        verb(
    template<typename Fun, typename ArgType>
    void caller(Fun fun, ArgType &&arg)
    {
        fun(std::forward<ArgType>(arg));
    }
        )
    A function tt(display(ostream &out)) and tt(increment(int &x)) may now
both be called through tt(caller). Example:
        verb(
    caller(display, cout);
    int x = 0;
    caller(increment, x);
        )
