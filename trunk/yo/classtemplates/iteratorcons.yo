    In section ref(ITERATORS) the iterators used with generic algorithms were
introduced. We've seen that several types of iterators were distinguished:
InputIterators, ForwardIterators, OutputIterators, BidirectionalIterators and
RandomAccessIterators. 

    To ensure that an object of a class is interpreted as a particular type of
iterator, the class must be derived from the class
    hi(iterator)tt(std::iterator).  Before a class can be derived from this
class the tthi(iterator) header file must have been included.

    In section ref(ITERATORS) the characteristics of iterators were
discussed. All iterators
 hi(iterator: common characteristics) should support an increment operation, a
dereference operation and a comparison for (in)equality.

    When hi(iterator: and generic algorithms) iterators must be used in the
context of generic algorithms they must meet additional requirements. This is
caused by the fact that generic algorithms check the types of the iterators
they receive. Simple pointers are usually accepted, but if an iterator-object
is used it must be able to specify the kind of iterator it represents.

    To ensure that an object of a class is interpreted as a particular type of
iterator, the class must be derived from the class tt(iterator). The
particular
 hi(iterator: class type) type of iterator is defined
by the class template's em(first) parameter, and the particular
 hi(iterator: data type) data type to which the iterator points is defined by
the class template's em(second) parameter.  

    The type of iterator that is implemented by the derived class
is specified using a so-called emi(iterator_tag), provided as the
first template argument of the class tt(iterator). For the five basic iterator
types, these tags are:
    itemization(
    itht(input_iterator_tag)(std::input_iterator_tag). This tag defines an
i(InputIterator).  Iterators of this type allow reading operations, iterating
from the first to the last element of the series to which the iterator refers.
    itht(output_iterator_tag)(std::output_iterator_tag). This tag defines an
i(OutputIterator).  Iterators of this type allow for assignment operations,
iterating from the first to the last element of the series to which the
iterator refers.
    itht(forward_iterator_tag)(std::forward_iterator_tag). This tag defines a
        tt(ForwardIterator).  Iterators of this type allow reading em(and)
assignment operations, iterating from the first to the last element of the
series to which the iterator refers.
    itht(bidirectional_iterator_tag)(std::bidirectional_iterator_tag). This
tag defines a i(BidirectionalIterator). Iterators of this type allow reading
em(and) assignment operations, iterating step by step, possibly in alternating
directions, over all elements of the series to which the iterator refers.
    itht(random_access_iterator_tag)(std::random_access_iterator_tag). This
tag defines a i(RandomAccessIterator).  Iterators of this type allow reading
em(and) assignment operations, iterating, possibly in alternating directions,
over all elements of the series to which the iterator refers using any
available (random) stepsize.
    )
    Each iterator tag assumes that a certain set of operators is
available. The em(RandomAccessIterator) is the most complex of iterators, as
it implies all other iterators.

    Note that iterators are always defined over a certain range
(rangett(begin, end)). Increment and decrement operations may result in
undefined behavior of the iterator if the resulting iterator value would refer
to a location outside of this range.

    Often, iterators only access the elements of the series to which they
refer. Internally, an iterator may use an ordinary pointer but it is hardly
ever necessary for the iterator to allocate its own memory. Therefore, as the
assignment operator and the copy constructor do not have to allocate any
memory, their em(default implementations) usually suffice.  For the same
reason iterators usually don't require destructors.

    Most classes offering members returning iterators do so by having members
construct the required iterators that are thereupon returned as objects by
those member functions. As the em(caller) of these member functions only has
to em(use) or sometimes em(copy) the returned iterator objects, there is
usually no need to provide any publicly available constructor, except for the
copy constructor. Therefore these constructors are usually defined as
em(private) or em(protected) members. To allow an outer class to create
iterator objects, the iterator class usually declares the outer class as its
em(friend).

    In the following sections the construction of a em(RandomAccessIterator),
the most complex of all iterators, and the construction of a em(reverse
RandomAccessIterator) is discussed. The container class for which a random
access iterator must be developed may actually store its data elements in many
different ways (e.g., using containers or pointers to pointers).  Therefore it
is difficult to construct a template iterator class which is suitable for a
large variety of container classes.

    In the following sections the available tt(std::iterator) class is used to
construct an inner class representing a random access iterator.  The reader
may follow the approach illustrated there to construct iterator classes for
other contexts. An example of such a template iterator class is provided in
section ref(CONCRETEITER).

The random access iterator developed in the next sections reaches data
elements that are only accessible through pointers. The iterator class is
designed as an inner class of a class derived from a vector of string
pointers.
