The tt(typedef) keyword is frequently used  to define `shorthand' notations
for extensive type names. Consider the following example:
        verb(
    typedef
       std::map<std::shared_ptr<KeyType>, std::vector<std::set<std::string>>>
            MapKey_VectorStringSet;

    MapKey_VectorStringSet mapObject;
        )
    In situations like this the actual type of the key or the data stored in
the map's vector might vary. Some may store tt(string) objects, other may
store tt(double) values.

A class may be defined based on the above tt(map) allowing the
specification of the final key and value types. Example:
        verb(
    template <typename DeepKey, typename DeepValue>
    class DeepMap: public std::map<std::shared_ptr<DeepKey>,
                            std::vector<std::set<DeepMap>>>
    {};
        )
    This increases the flexibility of the initially defined map as it is now
possible to write
        verb(
    DeepMap<KeyType, std::string> mapObject;
        )
    The C++0x standard adds to this the possibility to pre-specify either of
these template type parameters. To preset the key's type to tt(std::string)
leaving the data type open for later specification the following
    emi(template using declaration) hi(using: template declaration) syntax is
 available:
        verb(
    template<typename DeepValue>
    using MapString_DeepValue = DeepMap<std::string, DeepValue>;

    MapString_DeepValue<size_t> specialMap;
        )
    The tt(specialMap) now uses tt(shared_ptr<string>) for its key and
tt(vector<set<size_t>>) for its data type. A similar shorthand notation can
be used to pre-specify the value type leaving the key type open for later
specification.

    In addition to the above template syntax the ti(using) keyword
can also be used to separate a typedef name from a complex type
definition. Consider constructing a typedef defining a pointer to a function
expecting and returning a tt(double). The traditional way to define such a
type is as follows:
        verb(
    typedef double (*PFD)(double);
        )
    In  addition the C++0x standard offers the following alternative syntax:
        verb(
    using PFD = double (*)(double);
        )
