    When i(static members) are defined in class templates, they
        hi(class template: static members)
    are defined for every new type for which the class template is
instantiated. As they are static
members, there will only be one member per type for which the class template
is instantiated. For example, in a class like:
        verb(
    template <typename Type>
    class TheClass
    {
        static int s_objectCounter;
    };
        )
    There will be em(one) tt(TheClass<Type>::objectCounter) for each different
tt(Type) specification. The following object definitions result in the
instantiation of just one single static variable, shared among the two
objects:
        verb(
    TheClass<int> theClassOne;
    TheClass<int> theClassTwo;
        )
    Mentioning static members in interfaces does not mean these members are
actually defined. They are only em(declared) and must be em(defined)
separately.  With static members of class templates this is no different. The
definition of static members
        hi(class template: static members)
    is usually provided immediately following (i.e., below) the template class
interface. The static member tt(s_objectCounter) will usually be defined as
follows, just below its class interface:
        verb(
    template <typename Type>                    // definition, following
    int TheClass<Type>::s_objectCounter = 0;    // the interface
        )
    Here tt(s_objectCounter) is an tt(int) and thus independent of the
template type parameter tt(Type).

    In list-like constructions, where a i(pointer to objects) of the class
itself is required, the template type parameter tt(Type) must be used when
defining the static variable. Example:
        verbinclude(classtemplates/examples/statictype.cc)
    As usual, the definition can be read from the variable name back to the
beginning of the definition: tt(s_objectPtr) of the class tt(TheClass<Type>)
is a pointer to an object of tt(TheClass<Type>).

    When a static variable of a template's type parameter's type is defined,
it should of course not be given the initial value 0. The default constructor
(e.g., tt(Type()) is usually more appropriate). Example:
        verb(
    template <typename Type>                    // s_type's definition
    Type TheClass<Type>::s_type = Type();
        )
