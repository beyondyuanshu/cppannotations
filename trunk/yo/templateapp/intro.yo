The main purpose of templates is to provide a generic definition of classes
and functions which can then be tailored to specific types when required.

However, templates allow us to do more than that. If not for compiler
implementation limitations, templates could be used to program, compile-time,
just about anything we use computers for. This remarkable feat, offered by no
other current day computer language, stems from the fact that templates allow
us to do three things compile-time:
    itemization(
    it() Templates allow us to to integer arithmetic and to save computed
values symbolically;
    it() Templates allow us to make compile-time decisions;
    it() Templates allow us to do things repeatedly
    )

Of course, asking the compiler to compute, e.g., prime numbers, is one
thing. It's a completely different thing to do so in an award winning
way. Don't expect speed records to be broken when the compiler performs
complex calculations for us. But that's al beside the point, which is that we
em(can) ask the compiler to compute virtually anything using bf(C++)'s
template language.

In this chapter these remarkable features of templates are
discussed. Following a short overview of subtleties related to templates the
main characteristics of i(template meta programming) are introduced.

Following that discussion a third type of template parameter, the
    emi(template template parameter) is introduced, laying the groundwork for
the discusion of em(trait classes) and em(policy classes).

This chapter ends with the discussion of several additional and interesting
applications of templates: adapting compiler error messages, conversions to
class types and an elaborate example discussing compile-time list processing.

Much of the inspiration for this chapter resulted from two highly recommended
books: Andrei Alexandrescu's 2001 book
    hi(Alexandrescu, A.)bf(Modern C++ design) (Addison-Wesley) and Nicolai
Josutis and David Vandevoorde's 2003 book
    hi(Josutis, N.)hi(Vandevoorde, D.)bf(Templates) (Addison-Wesley)
