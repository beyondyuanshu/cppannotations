Being able to make choices is an essential feature of programming
languages. If we want to be able to `program the compiler' this feature must
be present in templates as well. Once again, realize that being able to make
choices in templates has em(nothing) to do with run-time execution of
programs. The essence of template meta programming is that we're em(not) using
or relying on any executable code in our template meta program. Of course, the
result will usually be executable code, but the particular code that is
produced must be a function of decisions the compiler can make by itself.

Since template (member) functions are only instantiated when they are actually
used, we can even define specializations of functions which are mutually
exclusive. I.e., it is possible to define a specialization which may be
compilable in one situation, but not in another, and a second specialization
which is compilable in the other situation, but not in the first
situation. This way code can be tailored to the demands of a concrete
situation.

A feature like this cannot be realized in code. For example, when designing a
generic storage class the software engineer may have the intention to store
both i(value class) type objects and objects of i(polymorphic class) types in
the storage class. From this point of departure the engineer may conclude that
the storage class should contain pointers to objects, rather than objects
themselves, and the following code may be conceived of:
        verb(
    template <typename Type>
    void Storage::add(Type const &obj)
    {
        d_data.push_back(
            d_ispolymorphic ?
                obj.clone()
            :
                new Type(obj)
        );
    }
        )
    The intent is to use the tt(clone()) member function of the tt(Type) class
if tt(Type) is a polymorphic class and the standard copy constructor if
tt(Type) is a value class.

    Unfortunately, this scheme will normally fail to compile as value classes
do not define tt(clone()) member functions and polymorphic base classes should
define
        hi(polymorphic class: copy constructors)
    their copy constructor in the class's private section. It doesn't matter
to the compiler that tt(clone()) is never called for value classes and the
copy constructor is never called for value type classes: it has some code to
compile, and can't do that because of missing members. It's as simple as that.

    Template meta programming comes to the rescue. Knowing that template
functions are only instantiated when used, we design em(specializations) of
our tt(add()) function, and provide our class tt(Storage) with an additional
(in addition to tt(Type) itself) template
non-type parameter indicating whether we'll use tt(Storage) for polymorphic or
non-polymorphic classes:
        verb(
    template <typename Type, bool isPolymorphic>
    class Storage
        ...
        )
    and we symply define overloaded versions of our tt(add()) member: the one
implementing the polymorphic class variant expecting tt(true) as its argument,
the one implementing the value class variant accepting tt(false) as its
argument.

    Again we run into a problem: overloading members cannot be based on
argument values, only on types. Fortunately there is a way out: in section
ref(INTTYPE) it was discussed how to convert integral values to types, and
knowledge of how to do this now comes in handy. The strategy is to define two
overloaded versions: one defining an tt(IntType<true>) parameter, implementing
the polymorphic class and one defining an tt(IntType<false>) parameter,
implementing the polymorphic class. In addition to these overloaded versions
of the member function tt(add()) the member tt(add()) itself calls the
appropriate overloaded member by providing an tt(IntType) argument,
constructed from tt(Storage)'s template non-type parameter. Here are the
implementations:

    Declared in tt(Storage)'s private section:
        verb(
    template <typename Type, bool isPolymorphic>
    void Storage<Type, isPolymorphic>::add(Type const &obj, IntType<true>)
    {
        d_data.push_back(obj.clone());
    }

    template <typename Type, bool isPolymorphic>
    void Storage<Type, isPolymorphic>::add(Type const &obj, IntType<false>)
    {
        d_data.push_back(new Type(obj));
    }
        )
    Declared in tt(Storage)'s public section:
        verb(
    template <typename Type, bool isPolymorphic>
    void Storage<Type, isPolymorphic>::add(Type const &obj)
    {
        add(obj, IntType<isPolymorphic>());
    }
        )

    In the above example making a selection was made possible by converting a
primitive value to a type and then (since  each concrete primitive value may be
used to construct a different type) using these types to define overloaded
versions of template member functions one of which is then called from a
(public) member using tt(IntType) to construct the appropriate selector type.

    Since template members are only instantiated when used, only one of the
overloaded private tt(add()) members is instantiated. Since the other one is
never called compilation errors are prevented.

    Some software engineers may have second thoughts when thinking about the
tt(Storage) class using pointers to store copies of value classes. Their
argument could be that value class objects can very well be stored by value,
rather than by pointer. In those cases we'd like to define the actual type
used for storing the values as either value types or pointer types. Situations
like these frequently occur in template meta programming and the following
tt(struct IfElse)
        hi(template: IfElse)
        hi(template: select type given bool)
    may be used to obtain one of two types, depending on a tt(bool) selector
value:
        verb(
    template<bool selector, typename FirstType, typename SecondType>
    struct IfElse
    {
        typedef FirstType TypeToUse;
    };
    template<typename FirstType, typename SecondType>
    struct IfElse<false, FirstType, SecondType>
    {
        typedef SecondType TypeToUse;
    };
        )
    The tt(IfElse) struct uses in its second definition a partial
specialization to select the tt(FalseType) if the tt(selector) is
tt(false). In all other cases (i.e., tt(selector == true)) the less specific
generic case is instantiated by the compiler, defining tt(FirstType) as the
tt(TypeToUse).

    The tt(IfElse) struct allows us to emi(templatize structural types): our
tt(Storage) class may use em(pointers) to store copies of polymorphic class
type objects, but em(values) to store value class type objects.
        verb(
    template <typename Type, bool isPolymorphic>
    class Storage
    {
        typedef typename IfElse<isPolymorphic, Type *, Type>::TypeToUse
                DataType;

        std::vector<DataType> d_data;

        private:
            void add(Type const &obj, IntType<true>);
            void add(Type const &obj, IntType<false>);
        public:
            void add(Type const &obj);
    }

    template <typename Type, bool isPolymorphic>
    void Storage<Type, isPolymorphic>::add(Type const &obj, IntType<true>)
    {
        d_data.push_back(obj.clone());
    }

    template <typename Type, bool isPolymorphic>
    void Storage<Type, isPolymorphic>::add(Type const &obj, IntType<false>)
    {
        d_data.push_back(obj);
    }

    template <typename Type, bool isPolymorphic>
    void Storage<Type, isPolymorphic>::add(Type const &obj)
    {
        add(obj, IntType<isPolymorphic>());
    }
        )
    The above example uses tt(IfElse)'s tt(TypeToUse), which is a type defined
by tt(IfElse) as either tt(FirstType) or tt(SecondType) to define the actual
data type to be used for tt(Storage)'s tt(std::vector) data type. To prevent
long data type definitions tt(Storage) defines its own type tt(DataType).

    The remarkable result in this example is that the em(structure) of the
tt(Storage) class's data is now depending on its template parameters. Since
the tt(isPolymorphic == true) situation uses different data types than
t(isPolymorphic == false) situation, the overloaded private tt(add()) members
can utilize this difference immediately. E.g., tt(add(Type const &obj,
IntType<false>)) now uses direct copy construction to stpre a copy of tt(obj)
in tt(d_vector).

    It is also possible to select a type from more than two alternatives. In
that case, tt(IfElse) structs can be nested. Remember that these structs never
have any effect on the run-time program, which simply is confronted with the
appropriate type, conditional to the type that's associated with the selector
value. The following example, defining tt(MapType) as a map having plain types
or pointers for either its key or its value type, illustrates this approach:
        verb(
    template <typename Key, typename Value, int selector>
    class Storage
    {
        typedef typename IfElse<
                    selector == 1,              // if selector == 1:
                    map<Key, Value>,            // use map<Key, Value>

                    typename IfElse<
                        selector == 2,          // if selector == 2:
                        map<Key, Value *>,      // use map<Key, Value *>

                        typename IfElse<
                            selector == 3,      // if selector == 3:
                            map<Key *, Value>,  // use map<Key *, Value>
                                                // otherwise:
                            map<Key *, Value *> // use map<Key *, Value *>

                        >::TypeToUse
                    >::TypeToUse
                >::TypeToUse
                MapType;

        MapType d_map;

        public:
            void add(Key const &key, Value const &value);
        private:
            void add(Key const &key, Value const &value, IntType<1>);
            ...
    };
    template <typename Key, typename Value, int selector>
    inline void Storage<selector, Key, Value>::add(Key const &key,
                                                   Value const &value)
    {
        add(key, value, IntType<selector>());
    }
        )
    The principle used in the above examples is: if different data types are
to be used in class templates, depending on template non-type parameters, an
tt(IfElse) struct can be used to define the appropriate type, and overloaded
member functions may utilize knowledge about the appropriate types to optimize
their implementations.

    Note that the overloaded functions have identical parameter lists as the
matching public wrapper function, but add to this parameterlist a specific
tt(IntType) type, allowing the compiler to select the appropriate overloaded
version, based on the template's non-type selector parameter.
