Next the selection of a type from a typelist given its index will be
discussed. This is the inverse operation from obtaining the index of a
`searchtype', as covered by section ref(SEARCHTYPE).

Rather than defining an tt(enum) value, the current algorithm should define a
type equal to the type at a given index position. If the type does not exist,
the typedef can be made a synonym of tt(NullType) since tt(NullType) cannot
appear in a typelist.

The following algorithm is used (the implementation of the parts is provided
immediately following the descriptions of the algorithm's steps):
    itemization(
    it() The foundation of the algorithm is provided by a declaration of
a struct tt(TypeAt), expecting an index and a typelist:
            verbinsert(TYPEAT)(templateapp/examples/typeat.h)

    it() If the typelist equals tt(NullType) define the return type as
tt(NullType) as well:
            verbinsert(NULLTYPE)(templateapp/examples/typeat.h)

    it() If the search index equals 0, define the return type as the
typelist's head:
            verbinsert(ZERO)(templateapp/examples/typeat.h)

    it() Otherwise, define the return type as the return type of the type at
offset index - 1 in the typelist's tail. Note the tt(typename) following
tt(typedef): it is required as the defining type's tt(result) type is a nested
type:
            verbinsert(TYPELIST)(templateapp/examples/typeat.h)
    )
    Assuming all required headers have been included, the following example
shows how tt(ListSearch) can be used:
        verb(
    int main()
    {
        typedef TYPELIST_3(int, char, bool) list3;
        enum { test = 2 };

        std::cout <<
            (ListSearch<TypeAt<test, list3>::result, list3>::index == -1 ?
                "Illegal Index\n"
            :
                "Index represents a valid type\n");
    }
        )
