    The keyword tt(typename) has been used until now to indicate a
        i(template type parameter). However, it is also used to disambiguate
code inside templates. Consider the following code:
        verb(
    template <typename Type>
    Type function(Type t)
    {
        Type::Ambiguous *ptr;

        return t + *ptr;
    }
        )
    When this code is shown to the compiler, it will complain with an -at
first sight puzzling- error message like:
        verb(
    demo.cc:4: error: 'ptr' was not declared in this scope
        )
    The puzzling nature of this error message is that the intention of the
programmer was actually to declare a pointer to a type tt(Ambiguous) defined
within the class template tt(Type). However, the compiler, when confronted
with tt(Type::Ambiguous) has to make a decision about the nature of this
construct. Clearly it cannot inspect tt(Type) to find out its true nature,
since tt(Type) is a template type, and hence its actual definition isn't
available yet. The compiler now is confronted with two possibilities: either
tt(Type::Ambiguous) is a em(static member) of the as yet mysterious template
tt(Type), or it is a em(subtype) defined by tt(Type). As the standard
specifies that the compiler must assume the former, the statement
        verb(
    Type::Ambiguous *ptr;
        )
    is eventually interpreted as a em(multiplication) of the static member
tt(Type::Ambiguous) and the (now undeclared) entity tt(ptr). The reason for
the error message should now be clear: in this context tt(ptr) is unknown.

    To disambiguate code in which an identifier refers to a
        hi(template: subtypes inside templates)
        hi(class template: subtype vs. static members)
type that is itself a subtype of a template type parameter the keyword
tt(typename) must be used. Accordingly, the above code is altered into:
        verb(
    template <typename Type>
    Type function(Type t)
    {
        typename Type::Ambiguous *ptr;

        return t + *ptr;
    }
        )
    Classes fairly often define subtypes. When such classes are thought of
when designing templates, these subtypes may appear inside the template's
definitions as subtypes of template type parameters, requiring the use of the
tt(template) keyword. E.g., assume a class template tt(Handler) defines a
tt(typename Container) as its type parameter, as well as a data member storing
the container's tt(begin()) iterator. Furthermore, the class template
tt(Handler) may offer a constructor accepting any container supporting a
tt(begin()) member. The skeleton of the class tt(Handler) could then be:
        verb(
    template <typename Container>
    class Handler
    {
        Container::const_iterator d_it;

        public:
            Handler(Container const &container)
            :
                d_it(container.begin())
            {}
    };
        )
    What were the considerations we had in mind when designing this class?
    itemization(
    it() The typename tt(Container) represents any container supporting
iterators.
    it() The container presumably supports a member tt(begin()). The
initialization tt(d_it(container.begin())) clearly depends on the
template's type parameter, so it's only checked for basic syntactical
correctness.
    it() Likewise, the container presumably supports a em(subtype)
tt(const_iterator), defined in the class tt(Container).
    )
    The final consideration is an indication that tt(typename) is required. If
this is omitted, and a tt(Handler) is instantiated because of the following
tt(main()) function one again a peculiar compilation error is generated:
        verb(
    #include "handler.h"
    #include <vector>
    using namespace std;

    int main()
    {
        vector<int> vi;
        Handler<vector<int> > ph(vi);
    }
    /*
        Reported error:

    handler.h:4: error: syntax error before `;' token
    */
        )
    Clearly the line
        centt(Container::const_iterator d_it;)
    in the tt(Handler) class causes a problem: it is interpreted by the
compiler as a em(static member) instead of a subtype. Again, the problem is
solved  using tt(typename):
        verb(
    template <typename Container>
    class Handler
    {
        typename Container::const_iterator d_it;
        ...
    };
        )
    An interesting illustration that the compiler indeed assumes tt(X::a) to
be a member tt(a) of the class tt(X) is provided by the error message we get
when we try to compile tt(main()) using the following implementation of
tt(Handler)'s constructor:
        verb(
    Handler(Container const &container)
    :
        d_it(container.begin())
    {
        size_t x = Container::ios_end;
    }
    /*
        Reported error:

        error: `ios_end' is not a member of type `std::vector<int,
                std::allocator<int> >'
    */
        )


    As a final illustration consider what happens if the function template
introduced at the beginning of this section doesn't return a tt(Type) value,
but a tt(Type::Ambiguous) value. Again, a subtype of a template type is
referred to, and tt(typename) is required:
        verb(
    template <typename Type>
    typename Type::Ambiguous function(Type t)
    {
        return t.ambiguous();
    }
        )
    Using tt(typename) in the specification of a return type is further
discussed in section (ref(RETURNNESTED)).

    In some cases tt(typename) can be avoided by resorting to a
        hi(template: avoiding typename)
tt(typedef). E.g., tt(Iterator), defined using tt(typedef), can be used to
indicate the specific type:
        verb(
    template <typename Container>
    class Handler
    {
        typedef typename Container::const_iterator Iterator;

        Iterator d_it;
        ...
    };
        )
