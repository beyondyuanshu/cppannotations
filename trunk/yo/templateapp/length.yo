To obtain the length of a typelist the following algorithm can be used:
        hi(typelist: length)
    itemization(
    it() If the typelist is empty, its size is zero
    it() If the typelist is non-empty, its size equals 1 plus the size of its
        tail.
    )
    Note how recursion is used to define the length of a typelist. In `normal'
bf(C++) code this recursion could be implemented as well, e.g., to determine
the length of a plain bf(C) (ascii-Z) string, resulting in something like:
        verb(
    size_t c_length(char const *cp)
    {
        return *cp == 0 ? 0 : 1 + c_length(cp + 1);
    }
        )
    In the context of template meta programming the alternatives that are used
to execute or terminate recursion are never written in one implementation, but
instead em(specializations)
        hi(typelist: specializations)
    are used: each specialization implements an alternative.

    The length of a typelist will be determined by a tt(struct ListSize)
ordinarily expecting a typelist as its template type parameter. It's merely
declared, since it turns out that only its specializations are required:
            verbinsert(LISTSIZE)(templateapp/examples/listsize.h)

    Following the above algorithm em(specializations) are now constructed:
    itemization(
    it() If the tt(ListSize)'s type is empty (i.e., a ti(NullType)), its size
        is 0:
            verbinsert(NULLTYPE)(templateapp/examples/listsize.h)

    it() Otherwise, its size will be 1 plus the size of the tail of a
        tt(TypeList):
            verbinsert(TYPELIST)(templateapp/examples/listsize.h)
    )
    That's all. The size of any typelist can now easily be determined. E.g.,
assuming all required headers (templates, iostream) have been included then
the following statement will (of course) display the value 3:
        verb(
    std::cout << ListSize<TYPELIST_3(int, char, bool)>::size << "\n";
        )
