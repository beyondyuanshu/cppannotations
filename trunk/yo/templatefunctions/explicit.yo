    In the previous section (section ref(TEMPFUNINST)) we've seen that the
compiler may encounter ambiguities when attempting to instantiate a
template. We've seen an example in which overloaded versions of a function
tt(fun()) existed, expecting different types of arguments, both of which could
have been provided by an instantiation of a function template. The intuitive
way to solve such an ambiguity is to use a tt(static_cast), but as noted: if
possible, casts should be avoided.

    When function templates are involved, such a tt(static_cast) may indeed
neatly be avoided, using emi(explicit template type arguments). When
explicit template type arguments are used the compiler is explicitly
informed about the actual template type parameters it should use when
instantiating a template. Here, the function's name is followed by an
        emi(actual template parameter type list)
        hi(template: actual template parameter type list)
    which may again be followed by the function's argument list, if
required. The actual types mentioned in the actual template parameter list
are used by the compiler to `deduce' the actual types of the corresponding
template types of the function's template parameter type list. Here is the
same example as given in the previous section, now using  explicit template
type arguments:
        verbinclude(templatefunctions/examples/explicit.cc)

    Explicit template argument types can be used in situations where the
compiler has no way to detect which types should actually be used. E.g., in
section ref(TEMPFUNARGS) the function template tt(Type fun()) was defined. To
instantiate this function for the tt(double) type, we can use
tt(fun<double>()).
