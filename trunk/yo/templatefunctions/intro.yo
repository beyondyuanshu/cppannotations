bf(C++) supports syntactical constructs allowing programmers to define and use
completely general (or abstract) functions or classes, based on generic types
and/or (possibly inferred) constant values. In the chapters on abstract
containers (chapter ref(Containers)) and the tt(STL) (chapter ref(STL)) we've
already used these constructs, commonly known as the
emi(template mechanism).

The template mechanism allows us to specify classes and algorithms,
fairly independently of the actual types for which the templates will
eventually be used. Whenever the template is used, the compiler will generate
code, tailored to the particular data type(s) used with the template. This
code is generated i(compile-time) from the template's definition. The piece of
generated code is called an emi(instantiation) of the template.

In this chapter the syntactical peculiarities of templates will be covered.
The notions of em(template type parameter), em(template non-type parameter),
and emi(function template) will be introduced, and several examples of
templates will be offered, both in this chapter and in chapter ref(CONCRETE),
providing concrete examples of bf(C++). Template em(classes)
    hi(class template) are covered in chapter ref(TEMPCLASS).

Templates offered standard by the language already cover containers allowing
us to construct both highly complex and standard data structures commonly used
in computer science. Furthermore, the tt(string) (chapter ref(String)) and
stream (chapter ref(IOStreams)) classes are commonly implemented using
templates. So, templates play a central role in present-day bf(C++), and
should absolutely not be considered an esoteric feature of the language.

Templates should be approached somewhat similarly as generic algorithms:
they're a emi(way of life); a bf(C++) software engineer should actively look
for opportunities to use them.  Initially, templates appear to be rather
complex, and you might be tempted to turn your back on them. However, in time
their strengths and benefits will be more and more appreciated. Eventually
you'll be able to recognize opportunities for using templates. That's the time
where your efforts should no longer focus on constructing ordinary
        hi(ordinary function)
        hi(ordinary class)
    (i.e., functions or classes that are not templates), but on constructing
templates.

This chapter starts by introducing em(function templates). The emphasis is on
the required syntax when defining such functions. This chapter lays the
foundation upon which the next chapter, introducing class templates and
offering several real-life examples, is built.
