In the previous chapters we have shown examples of classes where each object
of a class had its own set of ti(public) or ti(private) data. Each tt(public)
or tt(private) member could access any member of any object of its class.

In some situations it may be desirable that one or more
    emi(common data fields) exist, which are accessible to em(all) objects of
the class. For example, the name of the startup directory, used by
a program that recursively scans the directory tree of a disk. A second
example is a flag variable, which states whether some specific initialization
has occurred: only the first object of the class would perform the
necessary initialization and would set the flag to `done'.

Such situations are analogous to bf(C) code, where several functions need to
access the same variable. A common solution in bf(C) is to define all these
functions in one source file and to declare the variable as a ti(static): the
variable name is then not known beyond the scope of the source file. This
approach is quite valid, but violates our philosophy of using only one
function per source file. Another bf(C)-solution is to give the variable in
question an unusual name, e.g., tt(_6uldv8), hoping that other
program parts won't use this name by accident. Neither the first, nor the
second bf(C)-like solution is elegant.

bf(C++)'s solution is to define ti(static members): data and functions, common
to all objects of a class and inaccessible outside of the class.  These static
members are the topic of this chapter.
