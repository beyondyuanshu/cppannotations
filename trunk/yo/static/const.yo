Static tt(const) hi(data members: static const) data members may be
initialized in the class interface if these data members are of an integral
data type. So, in the following example the first three static data members
can be initialized since tt(int) tt(enum) and tt(double) types are integral
data members. The last static data member cannot be initialized in the class
interface since tt(string) is not an integral data type:
        verb(
    class X
    {
        public:
            enum Enum
            {
                FIRST,
            };

            static int const s_x = 34;
            static Enum const s_type = FIRST;

            static double const s_d = 1.2;
            static string const s_str = "a";    // won't compile
    };
        )
    Static tt(const) integral data members initialized in the class interface
are not i(addressable variables). They are mere symbolic names for their
associated values. Since they are not variables, it is not possible to
determine their addresses. Note that this is not a compilation problem, but a
linking problem. The static tt(const) variable that is initialized in the
class interface does not exist as an addressable entity.

    A statement like tt(int *ip = &X::s_x) will therefore em(compile)
correctly, but will fail to em(link).  Static variables that are explicitly
defined in a source file em(can) be linked correctly, though. So, in the
following example the address of tt(X::s_x) cannot be solved by the linker,
but the address of tt(X::s_y) em(can) be solved by the linker:
        verb(
    class X
    {
        public:
            static int const s_x = 34;
            static int const s_y;
    };

    int const X::s_y = 12;

    int main()
    {
        int const *ip = &X::s_x;    // compiles, but fails to link
        ip = &X::s_y;               // compiles and links correctly
    }
        )
