Static tt(const) hi(static data: const) data members may be initialized in the
class interface if these data members are of integral or built-in primitive
data types. So, in the following example the first three static data members
can be initialized since tt(int) and tt(double) are primitive built-in types
and tt(int) and tt(enum) types are integral types. The static data member
tt(s_str) cannot be initialized in the class interface since tt(string) is
neither a primitive built-in nor an integral data type:
        verb(
    class X
    {
        public:
            enum Enum
            {
                FIRST,
            };

            static int const s_x = 34;
            static Enum const s_type = FIRST;

            static double const s_d = 1.2;
            static string const s_str = "a";    // won't compile
    };
        )
    The compiler em(may) decide to initialize static tt(const) data members as
mere constant values, in which they don't have addresses. If the compiler does
so, such static tt(const) data members behave as though they were values of
an tt(enum) defined by the class.  Consequently they are not variables and so
it is not possible to determine their addresses. Note that trying to obtain
the address of such a constant value does not create a compilation problem,
but it em(does) create a linking problem as the static tt(const) variable that
is initialized as a mere constant value does not exist in addressable memory.

    A statement like tt(int *ip = &X::s_x) may therefore em(compile)
correctly, but may then fail to em(link).  Static variables that are
explicitly defined in a source file em(can) be linked correctly, though. So,
in the following example the address of tt(X::s_x) cannot be solved by the
linker, but the address of tt(X::s_y) em(can) be determined:
        verb(
    class X
    {
        public:
            static int const s_x = 34;
            static int const s_y;
    };

    int const X::s_y = 12;

    int main()
    {
        int const *ip = &X::s_x;    // compiles, but fails to link
        ip = &X::s_y;               // compiles and links correctly
    }
        )
