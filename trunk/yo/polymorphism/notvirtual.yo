In contrast to the previous definition of a class such as tt(AirAuto),
situations may arise where the hi(data members: multiply included) double
presence of the members of a base class is appropriate. To illustrate this,
consider the definition of a tt(Truck) from section ref(Truck):
        verb(
    class Truck: public Auto
    {
        int d_trailer_weight;

        public:
            Truck();
            Truck(int engine_wt, int sp, char const *nm,
                   int trailer_wt);

            void setWeight(int engine_wt, int trailer_wt);
            int weight() const;
    };

    Truck::Truck(int engine_wt, int sp, char const *nm,
                  int trailer_wt)
    :
        Auto(engine_wt, sp, nm)
    {
        d_trailer_weight = trailer_wt;
    }

    int Truck::weight() const
    {
        return                  // sum of:
            Auto::weight() +    //   engine part plus
            trailer_wt;         //   the trailer
    }
        )
    This definition shows how a tt(Truck) object is constructed to contain two
weight fields: one via its derivation from tt(Auto) and one via its own tt(int
d_trailer_weight) data member. Such a definition is of course valid, but it
could also be rewritten. We could derive a tt(Truck) from an tt(Auto)
em(and) from a tt(Vehicle), thereby explicitly requesting the double presence
of a tt(Vehicle); one for the weight of the engine and cabin, and one for the
weight of the trailer.
A small point of interest here is that a derivation like
        verb(
    class Truck: public Auto, public Vehicle
        )
    is not accepted by the bf(C++) compiler: a tt(Vehicle) is already part of
an tt(Auto), and is therefore not needed. An i(intermediate class) solves
the problem: we derive a class tt(TrailerVeh) from tt(Vehicle), and tt(Truck)
from tt(Auto) and from tt(TrailerVeh).  All ambiguities concerning the member
functions are then be solved for the class tt(Truck):
        verb(
    class TrailerVeh: public Vehicle
    {
        public:
            TrailerVeh(int wt);
    };

        inline TrailerVeh::TrailerVeh(int wt)
        :
            Vehicle(wt)
        {}

    class Truck: public Auto, public TrailerVeh
    {
        public:
            Truck();
            Truck(int engine_wt, int sp, char const *nm, int trailer_wt);
            void setWeight(int engine_wt, int trailer_wt);
            int weight() const;
    };

        inline Truck::Truck(int engine_wt, int sp, char const *nm,
                            int trailer_wt)
        :
            Auto(engine_wt, sp, nm),
            TrailerVeh(trailer_wt)
        {}

    inline int Truck::weight() const
    {
        return                      // sum of:
            Auto::weight() +        //   engine part plus
            TrailerVeh::weight();   //   the trailer
    }
        )
