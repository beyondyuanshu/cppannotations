As we have seen in chapter ref(INHERITANCE), bf(C++) provides the tools to
derive classes from base classes, and to use base class pointers to address
derived objects. As we've also seen, when using a i(base class pointer) to
address an object of a i(derived class), the type of the pointer determines
which i(member function) will be used. This means that a tt(Vehicle *vp),
pointing to a tt(Truck) object, will incorrectly compute the truck's combined
weight in a statement like tt(vp->weight()). The reason for this should now be
clear: tt(vp) calls tt(Vehicle::weight()) and not tt(Truck::weight()), even
though tt(vp) actually points to a tt(Truck).

Fortunately, a remedy is available. In bf(C++) a tt(Vehicle *vp) may call a
function tt(Truck::weight()) when the pointer actually points to a tt(Truck).

The terminology for this feature is emi(polymorphism): it is as though the
pointer tt(vp) changes its type from a base class pointer to a pointer to the
class of the object it actually points to.  So, tt(vp) might behave like a
tt(Truck *) when pointing to a tt(Truck), and like an tt(Auto *) when pointing
to an tt(Auto) etc..+footnote(In one of the StarTrek movies, Capt.  Kirk was
in trouble, as usual. He met an extremely beautiful lady who, however,
later on changed into a hideous troll. Kirk was quite surprised, but the lady
told him: ``Didn't you know I am a polymorph?'')

Polymorphism is realized by a feature called emi(late binding). It's called
that way because the decision em(which) function to call (a base class
function or a function of a derived class) cannot be made emi(compile-time),
but is postponed until the program is actually executed: only then it is
determined which member function will actually be called.
