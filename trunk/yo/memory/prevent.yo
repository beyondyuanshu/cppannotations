As we have seen, the operator tt(=) can be redefined for the class
tt(Person) in such a way that two objects of the class can be assigned,
resulting in two copies of the same object.

As long as the two variables are different ones, the previously presented
version of the function tt(operator=()) will behave properly: the memory of
the assigned object is released, after which it is allocated again to hold new
strings. However, when an object is assigned to itself (which is called
emi(auto-assignment)), a problem occurs: the allocated strings of the
receiving object are first deleted, resulting in the deletion of the
memory of the right-hand side variable, which we call emi(self-destruction).
An example of this situation is illustrated here:
        verb(
    void fubar(Person const &p)
    {
        p = p;          // auto-assignment!
    }
        )
    In this example it is perfectly clear that something unnecessary, possibly
even wrong, is happening. But auto-assignment can also occur in more hidden
forms:
        verb(
    Person one;
    Person two;
    Person *pp = &one;

    *pp = two;
    one = *pp;
        )
    The problem of auto-assignment can be solved using the ti(this)
pointer. In the i(overloaded assignment operator) function we simply test
whether the address of the right-hand side object is the same as the address
of the current object: if so, no action needs to be taken. The definition of
the function tt(operator=()) thus becomes:
        verb(
    void Person::operator=(Person const &other)
    {
        // only take action if address of the current object
        // (this) is NOT equal to the address of the other object

        if (this != &other)
        {
            delete d_name;
            delete d_address;
            delete d_phone;

            d_name = strdupnew(other.d_name);
            d_address = strdupnew(other.d_address);
            d_phone = strdupnew(other.d_phone);
        }
    }
        )
    This is the second version of the overloaded assignment function. One, yet
better version remains to be discussed.

    As a subtlety, note the usage of the em(address operator) 'tt(&)'
in the statement
        verb(
    if (this != &other)
        )
    The variable tt(this) is a pointer to the `current' object, while
tt(other) is a reference; which is an `alias' to an actual tt(Person)
object. The address of the other object is therefore tt(&other), while the
address of the current object is tt(this).
