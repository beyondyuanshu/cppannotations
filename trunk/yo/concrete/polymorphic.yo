Below the way Bisonc++ may use a polymorphic semantic value is described. The
described method is a direct result of a suggestion initially brought forward
by Dallas A. Clement in September 2007.

One may wonder why a tt(union) is still used by Bisonc++ as bf(C++) offers
inherently superior constructs to combine multiple types into one type. The
bf(C++) way to combine types into one type is by defining a polymorphic base
class and a series of derived classes implementing the alternative data
types. Bisonc++ supports the tt(union) approach (and the unrestricted unions
with C++0x) for various (e.g., backward compatibility)
reasons. bi(Bison) and bi(bison++) both support the tt(%union) directive.

An alternative to using a tt(union) is using a polymorphic base class. Such a
class is developed below (the class tt(Base)). As it is a polymorphic
base class it has the following characteristics:
    itemization(
    it() Its destructor is virtual (and has a default implementation);
    it() Objects of the derived classes may be obtained from a
        pure virtual tt(ownClone) member implementing a so-called em(virtual
        constructor) (cf. the emi(virtual constructor) i(design pattern),
        em(Gamma et al.) (1995)); hi(Gamma, E.);
    it() To obtain a clone of the current (derived class) object, the
        interface function tt(clone) must be called. It calls tt(ownClone) and
        forms a layer between the derived class implementations of
        tt(ownClone) and the user-software. Right now it only calls
        tt(ownClone), but by not defining it as an inline function ti(clone)
        can easily be extended once that is required;
    it() Several convenient utility members are defined: a pure virtual
        tt(insert) member and an overloaded tt(operator<<) to
        allow derived objects to be inserted into tt(ostream) objects.
    )
    Here is  bf(Base)'s interface:
    verbinclude(concrete/poly/base/base.h)

Instead of using fields of a  classical tt(union) we are now using
classes that are derived from the class tt(Base). For example:
    itemization(
    it() Objects of the class tt(Int) contain tt(int) values. Here is
its interface (and implementation):
        verbinclude(concrete/poly/int/int.h)
    it() Objects of the class tt(Text) contain text. These objects can be
used, e.g., to store the names of identifiers recognized by a lexical scanner.
Here is the interface of the class tt(Text):
        verbinclude(concrete/poly/text/text.h)
    )
    The polymorphic tt(Base) can't immediately be used as the parser's
semantic value type for various reasons:
    itemization(
    it() A tt(Base) class object cannot contain derived class's data members,
so plain tt(Base) class objects cannot be used to store the parser's semantic
values.
    it() It's not possible to define a tt(Base) class reference as a semantic
value either as containers cannot store references.
    it() Finally, the semantic value should not be a pointer to a tt(Base)
class object. Although a pointer would offer programmers the benefits of the
polymorphic nature of the tt(Base) class, it would also require them to keep
track of all memory used by tt(Base) objects, thus countering many of the
benefits of using a polymorphic base class.
    )

To solve the above problems, a em(wrapper class) tt(Semantic) around a
tt(Base) pointer is used. To simplify memory bookkeeping tt(Semantic) itself
is defined as a class derived from tt(std::shared_ptr) (cf. section
ref(SHAREDPTR)). This allows us to benefit from default implementations of the
copy constructor, the overloaded assignment operator, and the destructor.
tt(Semantic) itself offers an overloaded insertion operator allowing us to
insert the object that is controlled by the tt(Semantic) object and derived
from tt(Base) into an tt(ostream). Here is tt(Semantic)'s interface:
    verbinclude(concrete/poly/semantic/semantic.h)
