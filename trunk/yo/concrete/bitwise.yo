    In section ref(PREDEFINED) several types of i(predefined function objects)
were introduced. Predefined function objects performing
    i(arithmetic operations), i(relational operations), and
    i(logical operations) exist, corresponding to a multitude of
    hi(binary operator) binary- and hi(unary operator) unary operators.

    Some operators appear to be missing: there appear to be no predefined
function objects corresponding to i(bitwise operations). However, their
construction is, given the available predefined function objects, not
difficult. The following examples show a i(class template) implementing a
function object calling the i(bitwise and) (ti(operator&())), and a template
class implementing a function object calling the i(unary not)
(ti(operator~())). It is left to the reader to construct similar function
objects for other operators.

    Here is the implementation of a function object calling the i(bitwise)
tt(operator&()):
        verbinclude(concrete/examples/bitand.h)

    Here is the implementation of a function object calling tt(operator~()):
        verbinclude(concrete/examples/bitnot.h)

    These and other i(missing predefined function objects)
        hi(predefined function objects: missing) are also implemented in the
file ti(bitfunctional), which is found in the tt(cplusplus.yo.zip) archive. It
should be noted that these classes are derived from existing class templates
(e.g., ti(std::binary_function) and ti(std::unary_function)). These base
classes offer several typedefs which are expected (used) by various generic
algorithms as defined in the STL (cf. chapter ref(STL)), thus following the
advice offered in, e.g., the bf(C++) header file ti(bits/stl_function.h):
        verb(
   *  The standard functors are derived from structs named unary_function
   *  and binary_function.  These two classes contain nothing but typedefs,
   *  to aid in generic (template) programming.  If you write your own
   *  functors, you might consider doing the same.
        )

    Here is an example using tt(bit_and()) removing all odd numbers from a
vector of tt(int) values:
        verbinclude(concrete/examples/removeodd.cc)
