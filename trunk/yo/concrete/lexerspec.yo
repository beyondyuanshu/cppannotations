    The i(lexical scanner specification file) is organized similarly as the
one used for tt(flex) in bf(C) contexts. However, in bf(C++) contexts,
tt(flex) may create a class (tt(yyFlexLexer)) from which another class (e.g.,
tt(Scanner)) can be derived. Flex's specification file itself has three
sections:
    itemization(
    it() The lexer specification file's first section is a bf(C++)
em(preamble), containing code which can be used in the code defining the
actions that are performed once a regular expression has been matched. In the
current setup, where each class has its own em(internal header file), the
internal header file includes the file tt(scanner.h), in turn including
ti(FlexLexer.h), which is part of the tt(flex) distribution.  tt(FlexLexer.h)
has a peculiar setup, due to which it should not be read twice by the code
generated by tt(flex). So, we now have the following situation:
        itemization(
        it() First we look at the lexer specification file. It contains a
preamble including tt(scanner.ih). The class tt(Scanner) is declared in
tt(scanner.h), which is read by tt(scanner.ih). Therefore tt(Scanner)'s
members are known and can be called from the code associated with the regular
expressions defined in the lexer specification file.
        it() However, in tt(scanner.h), defining tt(class Scanner), the header
file tt(FlexLexer.h), declaring tt(Scanner)'s base class, em(must) have been
read by the compiler before the class tt(Scanner) itself is defined.
        it() Code generated by tt(flex) already includes tt(FlexLexer.h), and
as mentioned, tt(FlexLexer.h) may not be read twice. Unfortunately, tt(flex)
also inserts the specification file's preamble into the code it generates.
        it() Since this preamble includes tt(scanner.ih), and so
tt(scanner.h), and so tt(FlexLexer.h), we now em(do) include tt(FlexLexer.h)
twice in code generated by tt(flex). This must be prevented.
        )
        This is how  multiple inclusions of tt(FlexLexer.h) can be prevented:
        itemization(
        it() Although tt(scanner.ih) includes tt(scanner.h), tt(scanner.h)
itself is modified such that it includes tt(FlexLexer.h), em(unless) the bf(C)
preprocesser variable ti(SKIP_FLEXLEXER_) is defined.
        it() In tt(flex)' specification file tt(SKIP_FLEXLEXER_) is defined
just prior to including tt(scanner.ih).
        )
        Using this scheme, code generated by tt(flex) now re-includes
tt(FlexLexer.h). At the same time the compilation of tt(Scanner)'s members
proceeds independently of the lexer specification file's preamble, so here
tt(FlexLexer.h) is properly included too. Here is the specification files'
preamble:
            verbCinsert(PREAMBLE)(lexer/scanner/lexer)
    it() The specification file's second section is a tt(flex)
        emi(symbol area), used to define symbols, like a i(mini scanner), or
emi(options). The following options are suggested:
        itemization(
        it() ti(%option 8bit): allowing the generated lexical scanner to
read 8-bit characters (rather than 7-bit, which is the default).
        it() ti(%option c++): this results in tt(flex) generating bf(C++)
code.
        it() ti(%option debug): includes em(debugging)
        hi(flex: debugging code) code into the code generated by
tt(flex). Calling the member function hi(set_debug)hi(flex: set_debug)
tt(set_debug(true)) activates this debugging code at run-time. When activated,
information about which rules are matched is written to the standard error
stream. To suppress the execution of debug code the member function
tt(set_debug(false)) may be called.
        it() ti(%option noyywrap): when the scanner reaches the end of file,
it (by default) calls a function tt(yywrap) which may perform the switch
to another file. Calling this function is suppressed when tt(%option noyywrap)
is specified. Since there exist alternatives which render this function
superfluous (see below), it is suggested to specify this option as well.
        it() ti(%option outfile)tt(="yylex.cc"): this defines tt(yylex.cc) as
the name of the generated bf(C++) source file.
        it() ti(%option warn): this option is strongly suggested by the
tt(flex) documentation, so it's mentioned here as well. See tt(flex)'
documentation for details.
        it() ti(%option yyclass)tt(="Scanner"): this defines tt(Scanner) as
the name of the class derived from tt(yyFlexLexer).
        it() ti(%option yylineno): this option causes the lexical scanner to
keep track of the line numbers of the files it is scanning. When processing
nested files the variable tt(yylineno) is not automatically reset to the last
line number of a file when tt(yylex) returns to a partially processed file. In
those cases, tt(yylineno) must explicitly  be reset to a former
value. If specified, the current line number is returned by the public member
ti(lineno), returning an tt(int).
        )
    Here is the specification files' symbol area:
            verbCinsert(SYMBOLS)(lexer/scanner/lexer)
    it() The specification file's third section is a em(rules section), in
which the regular expressions and their associated actions are defined.
    In the example developed here,  the lexer should
copy information from the hi(yyin) tt(istream *yyin) to the
    hi(yyout) ti(ostream *yyout). For this  the predefined macro
    ti(ECHO) can be used.  Here is the rules section:
            verbCinsert(RULES)(lexer/scanner/lexer)
    )
    Since the derived class's members may now access the information stored
in the lexical scanner itself (it can even access the information
em(directly), since tt(yyFlexLexer)'s data members are i(protected), and
thus accessible to derived classes), most processing can be left to the
derived class's member functions.  This results in a very clean setup of the
lexer specification file, requiring no or hardly any code in the em(preamble).
