    The standard bf(C) library offers conversion functions like ti(atoi()),
tt(atol()), and other functions, which can be used to convert ti(ASCII-Z)
strings to numerical values. In bf(C++), these functions are still available,
but a more em(type safe) way to convert text to other types  is by using
objects of the class tt(std::istringsteam).

Using the tt(std::istringstream) class instead of the bf(C) standard
conversion functions may have the advantage of type-safety, but it also
appears to be a rather cumbersome alternative. After all, we will have to
construct and initialize a tt(std::istringstream) object first, before we're
actually able to extract a value of some type from it. This requires us to use
a variable. Then, if the extracted value is actually only needed to
initialize some function-parameter, one might wonder whether the additional
variable and the tt(istringstream) construction can somehow be avoided.

In this section we'll develop a class (ti(A2x)) preventing all the
disadvantages of the standard bf(C) library functions, without requiring the
cumbersome definitions of tt(std::istringstream) objects over and over
again. The class is called tt(A2x) for
    `i(ascii to anything)'.

    tt(A2x) objects can be used to obtain a value for any type extractable
from tt(std::istream) objects given its textual representation. Since tt(A2x)
represents the object-variant of the bf(C) functions, it is not only type-safe
but em(also) extensible. Consequently, their use is greatly preferred over the
standard bf(C) functions. Here are its characteristics:
    itemization(
    it()  tt(A2x) is derived from tt(std::istringstream), so all members
of the class tt(std::istringstream) are available. Thus, extractions of values
of variables can always be performed effortlessly. Here's the class's
interface:
        verbinsert(CLASS)(concrete/examples/a2x.h)
    it() tt(A2x) has a default constructor and a constructor expecting a
tt(std::string) argument. The latter constructor may be used to initialize
tt(A2x) objects with text to be converted (e.g., a line of text obtained from
reading a configuration file):
        verbinsert(CONS)(concrete/examples/a2x.h)
    it() tt(A2x)'s real strength comes from its tt(operator Type()) conversion
member template. As it is a member template, it will automatically adapt
itself to the type of the variable that should be given a value, obtained by
converting the text stored inside the tt(A2x) object to the variable's
type. When the extraction fails, tt(A2x)'s inherited tt(good()) member will
return tt(false).
    it() However, occasionally, the compiler may not be able to determine
which type to convert to. In that case, an em(explicit template type) could be
used:
        verb(
            A2x.operator int<int>();
            // or just:
            A2x.operator int();
        )
        As neither syntax looks attractive, the member template
tt(to()) was provided as well, allowing constructions like:
            centt(A2x.to<int>();)
        Here is its implementation:
            verbinsert(TO)(concrete/examples/a2x.h)
        allowing for a trivial implementation of tt(operator Type()):
            verbinsert(TYPE)(concrete/examples/a2x.h)
    it() Once an tt(A2x) object is available, it may be reinitialized using
its tt(operator=()) member:
            verbinclude(concrete/examples/a2xis.cc)
    )

    Here are some examples showing its use:
        verbinsert(MAIN)(concrete/examples/a2x.cc)

    A complementary class (ti(X2a)), converting values to text, can easily be
constructed as well. The construction of tt(X2a) is left as an exercise to
the reader.
