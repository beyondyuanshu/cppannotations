    The code associated with the i(regular expression) rules is located inside
the class ti(yyFlexLexer). However, we of course want to use the derived
class's members in this code. This causes a small problem. How does a
base-class member know about members of classes derived from it?

Inheritance helps us to overcome this problem. In the specification of
the class tt(yyFlexLexer), we notice that the function ti(yylex) is a
emi(virtual) function. The header file tt(FlexLexer.h) declares the
tt(virtual) member tt(int yylex):
        verb(
    class yyFlexLexer: public FlexLexer
    {
        public:
            yyFlexLexer( istream* arg_yyin = 0, ostream* arg_yyout = 0 );

            virtual ~yyFlexLexer();

            void yy_switch_to_buffer( struct yy_buffer_state* new_buffer );
            struct yy_buffer_state* yy_create_buffer( istream* s, int size );
            void yy_delete_buffer( struct yy_buffer_state* b );
            void yyrestart( istream* s );

            virtual int yylex();

            virtual void switch_streams( istream* new_in, ostream* new_out );
    };
        )
    As this function is virtual it can be overridden by a em(derived)
class. In that case the overridden function is called from its base class
(i.e., tt(yyFlexLexer)) code. And as the derived class's tt(yylex) function
is called, it has access to the members of the derived class, and (of course)
also to the public and protected members of its base class.

    By default, the context in which the generated scanner is placed is the
function hi(yylex)tt(yyFlexLexer::yylex). This context changes if we use a
derived class, e.g., tt(Scanner). To derive tt(Scanner) from tt(yyFlexLexer),
generated by tt(flex), do as follows:
    itemization(
    it() The function tt(yylex) must be declared in the derived class
tt(Scanner).
    it() em(Options) (see below) are used to inform tt(flex) about the derived
class's name.
    )

    Looking at the regular expressions themselves, notice that we need rules
to recognize comment, ti(#include) directives, and all remaining characters.
This is all fairly standard practice. When an tt(#include) directive is
sensed, the directive is parsed by the scanner. This too is common
practice. Our lexical scanner performs the following tasks:
    itemization(
    it() As usual, i(preprocessor directive)s are not
analyzed by a parser, but by the lexical scanner;
    it() The scanner uses a i(mini scanner) to extract the filename from the
directive, throwing a tt(Scanner::Error) value (tt(invalidInclude)) if this
fails;
    it() If the filename could be extracted, it is stored in tt(nextSource);
    it() When the tt(#include) directive has been processed, tt(pushSource) is
called to perform the switch to another file;
    it() When the end of the file (endOfFile()) is reached, the derived class's
member function tt(popSource) is called, popping the previously
pushed file and returning ti(true);
    it() Once the file-stack is empty, tt(popSource) returns ti(false),
resulting in calling tt(yyterminate), terminating the scanner.
    )
