    The code associated with the i(regular expression) rules is located inside
the class tt(yyFlexLexer). However, we would of course want to use the
derived class's members in this code. This causes a little problem: how does a
base-class member know about members of classes derived from it?

Fortunately, i(inheritance) helps us to realize this. In the specification of
the class tt(yyFlexLexer()), we notice that the function ti(yylex()) is a
emi(virtual) function. The header file tt(FlexLexer.h) declares the
tt(virtual) member tt(int yylex()):
        verb(
    class yyFlexLexer: public FlexLexer
    {
        public:
            yyFlexLexer( istream* arg_yyin = 0, ostream* arg_yyout = 0 );

            virtual ~yyFlexLexer();

            void yy_switch_to_buffer( struct yy_buffer_state* new_buffer );
            struct yy_buffer_state* yy_create_buffer( istream* s, int size );
            void yy_delete_buffer( struct yy_buffer_state* b );
            void yyrestart( istream* s );

            virtual int yylex();

            virtual void switch_streams( istream* new_in, ostream* new_out );
    };
        )
    As this function is a virtual function it can be overridden in a
em(derived) class. In that case the overridden function will be called from
its i(base class) (i.e., tt(yyFlexLexer)) code. Since the derived class's
tt(yylex()) is called, it will now have access to the members of the derived
class, and also to the public and protected members of its base class.

    By default, the context in which the generated scanner is placed is the
function ti(yyFlexLexer::yylex()). This context changes if we use a derived
class, e.g., tt(Scanner). To derive tt(Scanner) from tt(yyFlexLexer),
generated by tt(flex), do as follows:
    itemization(
    it() The function tt(yylex()) must be declared in the derived class
tt(Scanner).
    it() em(Options) (see below) are used to inform tt(flex) about the derived
class's name.
    )

    Looking at the regular expressions themselves, notice that we need
rules to  recognize comment, tt(#include) directives,
    hi(#include directive)
    and all remaining characters.  This is all fairly standard practice. When
an tt(#include) directive is detected, the directive is parsed by the
scanner. This too is i(common practice). Here is what our lexical scanner will
do:
    itemization(
    it() As usual, hi(preprocessor directive) preprocessor directives are not
analyzed by a i(parser), but by the i(lexical scanner);
    it() The scanner uses a i(mini scanner) to extract the filename from the
directive, throwing a tt(Scanner::Error) value (tt(invalidInclude)) if this
fails;
    it() If the filename could be extracted, it is stored in tt(nextSource);
    it() When the tt(#include) directive has been processed,
tt(pushSource()) is called to perform the switch to another file;
    it() When the end of the file (endOfFile()) is reached, the derived class's
member function tt(popSource()) is called, popping the previously
pushed file and returning ti(true);
    it() Once the file-stack is empty, tt(popSource()) returns ti(false),
resulting in calling tt(yyterminate()), terminating the scanner.
    )

    The i(lexical scanner specification) file is organized similarly as the
one used for tt(flex) in bf(C) contexts. However, for bf(C++) contexts,
tt(flex) may create a class (ti(yyFlexLexer)) from which another class (e.g.,
tt(Scanner)) can be
        hi(lexical scanner specification file)
derived. The i(flex specification file) itself has three sections:
    itemization(
    it() The lexer specification file's first section is a bf(C++)
emi(preamble), containing code which can be used in the code defining the
i(actions) to be performed once a regular expression is matched. In the
current setup, where each class has its own em(internal header file), the
internal header file includes the file tt(scanner.h), in turn including
ti(FlexLexer.h), which is part of the tt(flex) distribution.

    However, due to the complex setup of this latter file, it should not be
read again by the code generated by tt(flex). So, we now have the
following situation:
        itemization(
        it() First we look at the lexer specification file. It contains a
preamble including tt(scanner.ih), since this declares, via tt(scanner.h) the
class tt(Scanner), so that we're able to call tt(Scanner)'s members from the
code associated with the regular expressions defined in the lexer
specification file.
        it() In tt(scanner.h), defining tt(class Scanner), the header file
tt(FlexLexer.h), declaring tt(Scanner)'s base class, em(must) have been read
by the compiler before the class tt(Scanner) itself is defined.
        it() Code generated by tt(flex) already includes tt(FlexLexer.h),
and as mentioned, tt(FlexLexer.h) may not be read again. However, tt(flex) will
also insert the specification file's preamble into the code it generates.
        it() Since this preamble includes tt(scanner.ih), and so
tt(scanner.h), and so tt(FlexLexer.h), we now em(do) include tt(FlexLexer.h)
twice in code generated by tt(flex). This must be prevented.
        )
        To prevent multiple inclusions of tt(FlexLexer.h) the following is
suggested:
        itemization(
        it() Although tt(scanner.ih) includes tt(scanner.h), tt(scanner.h)
itself is modified such that it includes tt(FlexLexer.h), em(unless) the bf(C)
preprocesser variable ti(_SKIP_FLEXLEXER_) is defined.
        it() In tt(flex)' specification file tt(_SKIP_FLEXLEXER_) is defined
just prior to including tt(scanner.ih).
        )
        Using this scheme, code generated by tt(flex) will now re-include
tt(FlexLexer.h). At the same time, compiling tt(Scanner)'s members proceeds
independently of the lexer specification file's preamble, so here
tt(FlexLexer.h) is properly included too. Here is the specification files'
preamble:
            verbCinsert(PREAMBLE)(concrete/lexer/scanner/lexer)
    it() The specification file's second section is a tt(flex)
        emi(symbol area), used to define symbols, like a i(mini scanner), or
emi(options). The following options are suggested:
        itemization(
        it() ti(%option 8bit): this allows the generated lexical scanner to
read 8-bit characters (rather than 7-bit, which is the default).
        it() ti(%option c++): this results in tt(flex) generating bf(C++)
code.
        it() ti(%option debug): this will include em(debugging)
        hi(flex: debugging code) code into the code generated by
tt(flex). Calling the member function ti(set_debug(true)) will activate this
debugging code run-time. When activated, information about which rules are
matched is written to the standard error stream. To suppress the execution of
debug code the member function tt(set_debug(false)) may be called.
        it() ti(%option noyywrap): when the scanner reaches the end of file,
it will (by default) call a function tt(yywrap()) which may perform the switch
to another file to be processed. Since there exist alternatives which render
this function superfluous (see below), it is suggested to specify this option
as well.
        it() ti(%option outfile)tt(="yylex.cc"): this defines tt(yylex.cc) as
the name of the generated bf(C++) source file.
        it() ti(%option warn): this option is strongly suggested by the
tt(flex) documentation, so it's mentioned here as well. See tt(flex)'
documentation for details.
        it() ti(%option yyclass)tt(="Scanner"): this defines tt(Scanner) as
the name of the class derived from tt(yyFlexLexer).
        it()  ti(%option yylineno): this option causes the
lexical scanner to keep track of the i(line numbers) of the files it is
scanning. When processing nested files, the variable tt(yylineno) is not
automatically reset to the last line number of a file, when returning
to a partially processed file. In those cases, tt(yylineno) will explicitly
have to be reset to a former value. If specified, the current line number is
returned by the public member ti(lineno()), returning an tt(int).
        )
    Here is the specification files' symbol area:
            verbCinsert(SYMBOLS)(concrete/lexer/scanner/lexer)
    it() The specification file's third section is a emi(rules section), in
which the regular expressions and their associated actions are defined.
    In the example developed here,  the lexer should
    i(copy information) from the ti(istream) tt(*yyin) hi(yyin) to the
    hi(yyout) ti(ostream) tt(*yyout). For this  the predefined macro
    ti(ECHO) can be used.  Here is the specification files' symbol area:
            verbCinsert(RULES)(concrete/lexer/scanner/lexer)
    )
    Since the derived class's members may now access the information stored
within the lexical scanner itself (it can even access the information
em(directly), since the data members of tt(yyFlexLexer) are i(protected), and
thus accessible to derived classes), most processing can be left to the
derived class's member functions.  This results in a very clean setup of the
lexer specification file, requiring no or hardly any code in the em(preamble).
