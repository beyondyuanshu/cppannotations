    The tt(monitor) program uses a tt(Monitor) object doing most of the
work. The class tt(Monitor)'s public interface only offers a default
constructor and one member, tt(run), to perform its tasks.  All other member
functions are located in the class's tt(private) section.

    tt(Monitor) defines the tt(private) enum tt(Commands), symbolically
listing the various commands its input language supports, as well as several
data members.  Among the data members are a tt(Selector) object and a tt(map)
using child order numbers as its keys and pointer to tt(Child) objects (see
section ref(CHILD)) as its values. Furthermore, tt(Monitor) has a static array
member tt(s_handler[]), storing pointers to member functions handling user
commands.

    A destructor should be implemented as well, but its implementation is left
as an exercise to the reader. Here is tt(Monitor)'s interface, including the
interface of the nested class tt(Find) that is used to create a function
object:
        verbinsert(CLASS)(concrete/examples/monitor/monitor.h)

    Since there's only one non-class type data member, the class's constructor
could be implemented inline. The array
tt(s_handler), storing pointers to functions needs to be initialized as
well. This can be accomplished in several ways:
    itemization(
    it() Since the tt(Command) enumeration only contains a fairly limited set
of commands, compile-time initialization could be considered:
        verbinsert(HANDLER)(concrete/examples/monitor/data.compiletime)
    The advantage of this is that it's simple, not requiring any run-time
effort. The disadvantage is of course relatively complex maintenance. If for
some reason tt(Commands) is modified, tt(s_handler) must be modified as
well. In cases like these, compile-time initialization often is
asking for trouble. There is a simple alternative though.
    it() Looking at tt(Monitor)'s interface we see a static data member
tt(s_initialize) and a static member function tt(initialize). The static
member function handles the initialization of the tt(s_handler) array. It
explicitly assigns the array's elements and any modification in ordering of
the tt(enum Command)'s values is automatically accounted for by recompiling
tt(initialize):
        verbinsert(INIT)(concrete/examples/monitor/monitor.cc)
    The member tt(initialize) is a static member and so it can be
called to initialize tt(s_initialize), a static tt(int) variable. The
initialization is enforced by placing the initialization statement in the
source file of a function that is known to be executed. It could be tt(main),
but if we're tt(Monitor)'s maintainers and only have control over the library
containing tt(Monitor)'s code then that's not an option. In those cases the
source file containing the destructor is a em(very) good candidate. If a class
has only one constructor and it's em(not) defined inline then the
constructor's source file is a good candidate as well. In tt(Monitor)'s
current implementation the initialization statement is put in tt(run)'s source
file, reasoning that tt(s_handler) is only needed when tt(run) is used.
    )
 tt(Monitor)'s constructor is a very simple function and may be implemented
inline:
        verbinsert(CONS)(concrete/examples/monitor/monitor.h)

    The core of tt(Monitor)'s activities are performed by tt(run). It
performs the following tasks:
    itemization(
    it() Initially, the tt(Monitor) object only monitors its standard
input. The set of input file descriptors to which tt(d_selector) listens
is initialized to tt(STDIN_FILENO).
    it() Then, in a loop  tt(d_selector)'s tt(wait) function is called.
If input on tt(cin) is available, it is processed by tt(processInput).
Otherwise, the input has arrived from a child process. Information sent by
children is processed by tt(processChild).
    it() To prevent emi(zombie)em(s), the child processes must catch em(their)
children's termination signals. This is discussed below (in an earlier version
tt(Monitor) caught the termination signals. As noted by Ben Simons (tt(ben at
mrxfx dot com)) this is inappropriate. Instead, the process spawning child
processes has that responsibility (so, the parent process is responsible for
its child processes; a child process is in turn responsible for its own child
processes). Thanks, Ben).
    it() As stated, tt(run)'s source file also defines and initializes
tt(s_initialize) to ensure the proper initialization of the tt(s_handler)
array.
    )
    Here is tt(run)'s implementation and tt(s_initialize)'s definition:
        verbinclude(concrete/examples/monitor/run.cc)

    The member function tt(processInput) reads the commands entered by the
user using the program's standard input stream. The member itself is rather
simple. It calls tt(next) to obtain the next command entered by the user, and
then calls the corresponding function using the matching element of the
tt(s_handler[]) array. Here are the members tt(processInput) and tt(next):
        verbinsert(INPUT)(concrete/examples/monitor/processinput.cc)
        verbinsert(NEXT)(concrete/examples/monitor/processinput.cc)

    All other input sensed by tt(d_select) is created by child
processes. Because tt(d_select)'s tt(readFd) member returns the corresponding
input file descriptor, this descriptor can be passed to
tt(processChild). Using a ti(IFdStreambuf) (see section ref(IFDBUF)), its
information is read from an input stream. The communication protocol used here
is rather basic. For every line of input sent to a child, the child replies by
sending back exactly one line of text. This line is then read by
tt(processChild):
        verbinsert(CHILD)(concrete/examples/monitor/processchild.cc)
    The construction tt(d_child[fd]->pid()) used in the above source deserves
some special attention. tt(Monitor) defines the data member tt(map<int,
shared_ptr<Child>> d_child).  This map contains the child's order number as
its key, and a (shared) pointer to the tt(Child) object as its value. A shared
pointer is used here, rather than a tt(Child) object, since we want to use the
facilities offered by the map, but don't want to copy a tt(Child) object time
and again.

    Now that tt(run)'s implementation has been covered, we'll concentrate on
the various commands users might enter:
    itemization(
    it() When the tt(start) command is issued, a new child process is started.
A new element is added to tt(d_child) by the member tt(createNewChild).  Next,
the tt(Child) object should start its activities, but the tt(Monitor) object
can not wait for the child process to complete its activities, as there is no
well-defined endpoint in the near future, and the user will probably want to
enter more commands. Therefore, the tt(Child) process must run as a
emi(daemon). So the forked process terminates immediately, but its own child
process will continue to run (in the background). Consequently,
tt(createNewChild) calls the child's tt(fork) member. Although it is the
child's tt(fork) function that is called, it is still the monitor program
wherein that tt(fork) function is called. So, the em(monitor) program is
duplicated by tt(fork). Execution then continues:
    itemization(
    it() At the tt(Child)'s tt(parentProcess) in its parent process;
    it() At the tt(Child)'s tt(childProcess) in its child process
    )
    As the tt(Child)'s tt(parentProcess) is an empty function, returning
immediately, the tt(Child)'s parent process effectively continues immediately
below tt(createNewChild)'s tt(cp->fork()) statement.  As the child process
never returns (see section ref(CHILD)), the code below tt(cp->fork()) is never
executed by the tt(Child)'s child process. This is exactly as it should be.

    In the parent process, tt(createNewChild)'s remaining code simply
adds the file descriptor that's available for reading information from the
child to the set of input file descriptors monitored by tt(d_select), and
uses tt(d_child) to  establish the association between that
file descriptor and the  tt(Child) object's address:
        verbinsert(CHILD)(concrete/examples/monitor/createnewchild.cc)
    it() Direct communication with the child is required for the tt(stop <nr>)
and tt(<nr> text) commands. The former command terminates child process
tt(<nr>), by calling tt(stopChild). This function locates the child process
having the order number using an anonymous object of the class tt(Find),
nested inside tt(Monitor). The class tt(Find) simply compares the
provided tt(nr) with the children's order number returned by their tt(nr)
members:
        verbinsert(FIND)(concrete/examples/monitor/monitor.h)
    If the child process having order number tt(nr) was found, its file
descriptor is removed from tt(d_selector)'s set of input file
descriptors. Then the child process itself is terminated by the static member
tt(killChild). The member tt(killChild) is declared as a em(static) member
function, as it is used as function argument of the tt(for_each) generic
algorithm by tt(erase) (see below). Here is tt(killChild)'s
implementation:
        verbinsert(KILL)(concrete/examples/monitor/monitor.cc)
    Having terminated the specified child process, the corresponding tt(Child)
object is destroyed and its pointer is removed from tt(d_child):
        verbinsert(STOP)(concrete/examples/monitor/stopchild.cc)
    it() The command tt(<nr> text>) sends tt(text) to child process
tt(nr) using the member function tt(sendChild). This function too, will
use a tt(Find) object to locate the process having order number tt(nr), and
then simply inserts the text into the writing end of a pipe connected to
the indicated child process:
        verbinsert(SEND)(concrete/examples/monitor/sendchild.cc)
    it() When users enter tt(exit) or tt(quit) the member tt(exiting) is
called.  It terminates all child processes using the ti(for_each) generic
algorithm (see section ref(FOREACH)) to visit all elements of
tt(d_child). Then the program itself ends:
        verbinsert(EXIT)(concrete/examples/monitor/monitor.cc)
    )
    The program's tt(main) function is simple and needs no further comment:
        verbinsert(MAIN)(concrete/examples/monitor/main.cc)
