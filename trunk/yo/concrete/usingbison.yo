When an i(input language) exceeds a certain level of complexity, a emi(parser)
is often used to control the complexity of the input language. In this case, a
emi(parser generator) can be used to generate the code verifying the input's
i(grammatical correctness).  The i(lexical scanner) (preferably composed into
the parser) provides chunks of the input, called emi(tokens). The parser then
processes the series of tokens generated by its lexical scanner.

Starting point when developing programs that use both parsers and scanners is
the i(grammar). The grammar defines a em(set of tokens) which can be returned
by the lexical scanner (commonly called the emi(lexer)).

Finally, auxiliary code is provided to `fill in the blanks': the i(actions)
performed by the parser and by the lexer are not normally specified literally
in the i(grammatical rules) or lexical i(regular expressions), but should be
implemented in em(member functions), called from within the parser's
rules or which are associated with the lexer's regular expressions.

In the previous section we've seen an example of a bf(C++) class generated by
ti(flex). In the current section we concentrate on the parser. The
parser can be generated from a grammar specification, processed by the
program ti(bisonc++). The grammar specification required for tt(bisonc++) is
similar to the specifications required for ti(bison) (and an existing program
ti(bison++), written in the early nineties by the Frenchman
    hi(Coetmeur, A.) em(Alain Coetmeur)), but tt(bisonc++) generates a
bf(C++) which more closely follows present-day standards than tt(bison++),
which still shows many bf(C)-like features.

    In this section a program is developed converting
    emi(infix expressions), in which binary operators are written between
their operands, to emi(postfix expressions), in which binary operators are
written behind their operands. Furthermore, the unary operator tt(-) will be
converted from its prefix notation to a postfix form.  The unary tt(+)
operator is ignored as it requires no further actions. In essence our little
calculator is a micro compiler, transforming numerical expressions into
assembly-like instructions.

Our i(calculator) will recognize a very basic set of operators:
i(multiplication), i(addition), i(parentheses), and the unary minus. We'll
distinguish i(real numbers) from integers, to illustrate a subtlety in
bison-like grammar specifications. That's all. The purpose of this section is,
after all, to illustrate the construction of a bf(C++) program that uses both
a parser and a lexical scanner, rather than to construct a full-fledged
calculator.

In the coming sections we'll develop the grammar specification for
tt(bisonc++). Then, the regular expressions for the scanner are specified
according to tt(flex)' requirements. Finally the program is constructed.
