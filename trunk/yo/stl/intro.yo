The ti(Standard Template Library) (i(STL)) is a i(general purpose library)
consisting of i(containers),
    i(generic algorithms), i(iterators), i(function objects),
    allocators, i(adaptors) and i(data structures). The data structures used
in the algorithms are em(abstract) in the sense that the algorithms can be
used on (practically) every data type.

The algorithms can work on these i(abstract data types) due to the fact that
they are emi(template) based algorithms. In this chapter the em(construction)
of templates is not discussed (see chapter ref(TEMPLATES) for that). Rather,
this chapter focuses on the em(use) of these template algorithms.

Several parts of the standard template library have already been discussed in
the bf(C++) Annotations. In chapter ref(Containers) the abstract containers
were discussed, and in section ref(FUNOBJ) function objects were introduced.
Also, em(iterators) were mentioned at several places in this
document.

The remaining components of the STL will be covered in this
chapter. Iterators, adaptors and generic algorithms will be discussed in the
coming sections. em(Allocators) take care of the memory allocation within the
STL. The default i(allocator class) suffices for most applications, and is
not further discussed in the bf(C++) Annotations.

Forgetting to delete i(allocated memory) is a common source of errors or
memory leaks in a program. The ti(auto_ptr) class template may be used to
prevent these types of problems. The tt(auto_ptr) class is discussed in
section ref(AUTOPTR).

All elements of the STL are defined in the standard namespace. Therefore, a
tt(using namespace std) or comparable directive is required unless it is
preferred to specify the required namespace explicitly. This occurs in at
least one situation: in header files no tt(using) directive should be used,
so here the tt(std::) scope specification should always be specified when
referring to elements of the STL.
