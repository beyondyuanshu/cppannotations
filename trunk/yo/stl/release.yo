As we saw in section ref(AUTOOTHER), when an tt(auto_ptr) is assigned to
another tt(auto_ptr), the pointer providing the value loses its value and is
reinitialized to 0. If that's not what we want, the member function
tt(release()) may be used.

The tt(release()) member function returns the address of the underlying
pointer used by the tt(auto_ptr) object, and releases the ownership of the
object at the same time. The ownership can then be taken over by another
tt(auto_ptr) variable (or, indeed, by any other pointer).

In the following example a pointer is initialized, and then another pointer is
created to point to the same string as the first tt(auto_ptr) points to. The
first tt(auto_ptr) still points to the string, but doesn't own the string
anymore. Therefore, when the first tt(auto_ptr) goes out of scope, it won't
delete the string pointed to by the second tt(auto_ptr).
 verbinclude(stl/auto/auto.cc)
