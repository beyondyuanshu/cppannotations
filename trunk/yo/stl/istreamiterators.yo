The ti(istream_iterator<Type>()) can be used to define an iterator (pair) for
ti(istream) objects. The general form of the tt(istream_iterator<Type>())
iterator is:
        verb(
    istream_iterator<Type> identifier(istream &inStream)
        )
    Here, tt(Type) is the type of the data elements that are read from
the tt(istream) stream. tt(Type) may be any type for which oprshift() is
defined with tt(istream) objects.

    The i(default constructor) defines the end of the iterator pair,
corresponding to i(end-of-stream). For example,
        verb(
    istream_iterator<string> endOfStream;
        )
    Note that the actual em(stream) object which was specified for the
begin-iterator is em(not) mentioned here.

    Using a link(tt(back_inserter()))(INSERTER) and a set of
tt(istream_iterator<>()) adaptors, all strings could be read from tt(cin) as
follows:
        verbinclude(stl/cc/istreamiterator.cc)
    In the above example, note the use of the i(anonymous) versions of the
tt(istream_iterator) adaptors. Especially note the use of the anonymous
default constructor. The following (non-anonymous) construction could have
been used instead of tt(istream_iterator<string>()):
        verb(
    istream_iterator<string> eos;

    copy(istream_iterator<string>(cin), eos, back_inserter(vs));
        )
    Before tt(istream_iterators) can be used the following preprocessor
directive must have been specified: hi(#include <iterator>)
        verb(
    #include <iterator>
        )
    This is implied when ti(iostream) is included.
