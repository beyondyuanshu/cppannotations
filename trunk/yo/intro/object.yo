Object-oriented (and object-based) programming propagates a slightly different
approach to programming problems than the strategy usually used in bf(C)
programs. In bf(C) programming problems are usually solved using a
`i(procedural approach)': a problem is decomposed into subproblems and this
process is repeated until the subtasks can be coded. Thus a conglomerate of
functions is created, communicating through arguments and variables, global or
local (or tt(static)).

In contrast (or maybe better: in addition) to this, an object-based approach
identifies bf(keywords) in a problem. These keywords are then depicted
in a diagram and arrows are drawn between these keywords to define an internal
hierarchy. The keywords will be the objects in the implementation and the
hierarchy defines the relationship between these objects. The term object is
used here to describe a limited, well-defined structure, containing all
information about an entity: data types and functions to manipulate the
data. As an example of an i(object oriented approach), an illustration
follows:
    quote(
    The employees and owner of a car dealer and auto garage company are paid
    as follows. First, mechanics who work in the garage are paid a certain sum
    each month. Second, the owner of the company receives a fixed amount each
    month. Third, there are car salesmen who work in the showroom and receive
    their salary each month plus a bonus per sold car. Finally, the company
    employs second-hand car purchasers who travel around; these employees
    receive their monthly salary, a bonus per bought car, and a restitution of
    their travel expenses.
    )
    When representing the above salary administration, the keywords could be
mechanics, owner, salesmen and purchasers. The properties of such units are: a
monthly salary, sometimes a bonus per purchase or sale, and sometimes
restitution of travel expenses. When analyzing the problem in this manner we
arrive at the following representation:
    itemization(
    it() The owner and the mechanics can be represented as the same type,
receiving a given salary per month. The relevant information for such a type
would be the monthly amount. In addition this object could contain data as the
name, address and social security number.
    it() Car salesmen who work in the showroom can be represented as the same
type as above but with some em(extra) functionality: the number of
transactions (sales) and the bonus per transaction.

    In the hierarchy of objects we would define the dependency between the
first two objects by letting the car salesmen be `derived' from
the owner and mechanics.
    it() Finally, there are the second-hand car purchasers. These share the
functionality of the salesmen except for the travel expenses. The additional
functionality would therefore consist of the expenses made and this type would
be derived from the salesmen.
    )
    The hierarchy of the thus identified objects are further illustrated in
fig(objects).
    figure(intro/objects)(Hierarchy of objects in the salary administration.)
    (objects)

The overall process in the definition of a hierarchy such as the above starts
with the description of the most simple type. Subsequently more complex types
are derived, while each derivation adds a little functionality. From these
derived types, more complex types can be derived em(ad infinitum), until a
representation of the entire problem can be made.

In bf(C++) each of the objects can be represented in a
link(em(class))(Classes), containing the necessary functionality to do useful
things with the variables (called em(objects)) of these classes. Not all of
the functionality and not all of the properties of a class are usually
available to objects of other classes. As we will see, classes tend to
em(hide) their properties in such a way that they are not directly modifiable
by the outside world. Instead, dedicated functions are used to reach or modify
the properties of objects. Also, these objects tend to be
em(self-contained). They em(encapsulate) all the functionality and data
required to perform their tasks and to uphold the object's integrity.
