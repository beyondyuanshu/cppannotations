In bf(C++) it is possible to define
    i(functions having identical names) but performing different actions. The
functions must differ in their hi(parameter list) parameter lists (and/or in
their hi(const function attribute) tt(const) attribute). An example is given
below:
        verb(
    #include <stdio.h>

    void show(int val)
    {
        printf("Integer: %d\n", val);
    }

    void show(double val)
    {
        printf("Double: %lf\n", val);
    }

    void show(char *val)
    {
        printf("String: %s\n", val);
    }

    int main()
    {
        show(12);
        show(3.1415);
        show("Hello World\n!");
    }
        )
    In the above fragment three functions tt(show()) are defined, which only
differ in their parameter lists: tt(int), tt(double) and tt(char *). The
functions have identical names. The definition of several functions having
identical names is called `i(function overloading)'.

    It is interesting that the way in which the bf(C++) compiler implements
function overloading is quite simple. Although the functions share the same
name in the source text (in this example tt(show())), the compiler (and hence
the linker) use quite different names. The conversion of a name in the source
file to an internally used name is called `i(name mangling)'. E.g., the
bf(C++) compiler might convert the name tt(void) tt(show) tt((int)) to the
internal name tt(VshowI), while an analogous function with a tt(char*)
argument might be called tt(VshowCP). The actual names which are internally
used depend on the compiler and are not relevant for the programmer, except
where these names show up in e.g., a listing of the contents of a library.

A few remarks concerning function overloading are:
    itemization(
    it() Do not use function overloading for functions doing conceptually
different tasks.  In the example above, the functions tt(show()) are still
somewhat related (they print information to the screen).

    However, it is also quite possible to define two functions tt(lookup()),
one of which would find a name in a list while the other would determine the
video mode. In this case the two functions have nothing in common except for
their name. It would therefore be more practical to use names which suggest
the action; say, tt(findname()) and tt(vidmode()).
    it() bf(C++) does not allow identically named functions to differ only in
their return value, as it is always the programmer's choice to either use or
ignore the return value of a function. E.g., the fragment
        verb(
    printf("Hello World!\n");
        )
    holds no information concerning the return value of the function
tt(printf()). Two functions tt(printf()) which would only differ in their
return type could therefore not be distinguished by the compiler.
    it() Function overloading can produce surprises. E.g., imagine a
    statement like
        verb(
    show(0);
        )
    given the three functions tt(show()) above. The zero could be interpreted
here as a tt(NULL) pointer to a tt(char), i.e., a tt((char *)0), or as an
integer with the value zero. Here, bf(C++) will call the function
expecting an integer argument, which might not be what one expects.
    it() In chapter ref(Classes) the notion of tt(const) member functions will
be introduced (cf. section ref(ConstFunctions)). Here it is merely mentioned
that classes normally have so-called member functions associated with them
(see, e.g., chapter ref(String) for an informal introduction of the
concept). Apart from
    hi(member functions: overloading)
    overloading member functions using different parameter lists, it
is then also possible to
    hi(overloading: by const attribute)
    overload member functions by their tt(const)
attributes. In those cases, classes may have pairs of identically named member
functions, having identical parameter lists. Then, these functions are
overloaded by their tt(const) attribute: one of these function must
have the tt(const) attribute, and the other must not.
    )
