In bf(C++) it is allowed to define i(functions as part of a struct). Here we
encounter the first concrete example of an object: as previously was described
(see section ref(OOP)), an i(object) is a structure containing all involved
code and data.

A definition of a tt(struct point) is given in the code fragment below.
In this structure, two tt(int) data fields and one function tt(draw()) are
declared.
        verb(
    struct point            // definition of a screen
    {                       // dot:
        int x;              // coordinates
        int y;              // x/y
        void draw(void);    // drawing function
    };
        )
    A similar structure could be part of a painting program and could, e.g.,
represent a pixel in the drawing. With respect to this tt(struct) it should be
noted that:
    itemization(
    it() The function tt(draw()) mentioned in the tt(struct) definition is a
mere em(declaration). The actual code of the function, or in other words the
actions performed by the function, are located elsewhere. We will describe the
actual definitions of functions inside tt(struct)s later (see section
ref(FunctionsInStructs)).
    it() The size of the tt(struct) tt(point) is equal to the size of its
two tt(int)s.  A function declared inside the structure does not affect its
size. The compiler implements this behavior by allowing the function
tt(draw()) to be known only in the context of a tt(point).
    )
    The tt(point) structure could be used as follows:
        verb(
    point a;                // two points on
    point b;                // the screen

    a.x = 0;                // define first dot
    a.y = 10;               // and draw it
    a.draw();

    b = a;                  // copy a to b
    b.y = 20;               // redefine y-coord
    b.draw();               // and draw it
        )
    The function that is part of the structure is selected in a similar
manner in which data fields are selected; i.e., using the
    i(field selector operator) (tt(.)). When pointers to tt(struct)s are used,
tt(->) can be used.

    The idea behind this syntactical construction is that several types may
contain i(functions having identical names). E.g., a structure representing a
circle might contain three tt(int) values: two values for the coordinates of
the center of the circle and one value for the radius. Analogously to the
tt(point) structure, a function tt(draw()) could be declared which would draw
the circle.
