Earlier it was mentioned that functions can be part of tt(struct)s (see
section ref(FunctionInStruct)).  Such functions are called
    emi(member functions) or emi(methods).
This section discusses how to define such functions.

The code fragment below illustrates a tt(struct) having data fields for a
name and an address. A function tt(print()) is included in the
tt(struct) definition:
        verb(
    struct Person
    {
        char name[80],
        char address[80];

        void print();
    };
        )
    The member function tt(print()) is defined using the structure name
(tt(Person)) and the scope resolution operator (tt(::)):
        verb(
    void Person::print()
    {
        cout << "Name:      " << name << endl
                "Address:   " << address<< endl;
    }
        )
    In the definition of this member function, the function name is preceded
by the tt(struct) name followed by tt(::). The code of the function shows how
the fields of the tt(struct) can be addressed without using the type name: in
this example the function tt(print()) prints a variable tt(name). Since
tt(print()) is a part of the tt(struct) tt(person), the variable tt(name)
implicitly refers to the same type.

This tt(struct) could be used as follows:
        verb(
    Person p;

    strcpy(p.name, "Karel");
    strcpy(p.address, "Rietveldlaan 37");
    p.print();
        )
    The advantage of member functions lies in the fact that the called
function can automatically address the data fields of the structure for which
it was invoked. As such, in the statement tt(p.print()) the structure tt(p) is
the `substrate': the variables tt(name) and tt(address) which are used in the
code of tt(print()) refer to the same tt(struct p).
