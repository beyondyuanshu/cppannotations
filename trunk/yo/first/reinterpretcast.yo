The third new-style cast is used to change the em(interpretation) of
information: the tt(reinterpret_cast). It is somewhat reminiscent of the
tt(static_cast), but tt(reinterpret_cast) should be used when it is em(known)
that the information as defined in fact is or can be interpreted as something
completely different. Its syntax is:
        centt(reinterpret_cast<pointer type>(pointer expression))

 A ti(reinterpret_cast<type>(expression)) operator is appropriately used to
reinterpret a tt(void *) to a pointer of a well-known type. Void pointers are
encountered with functions from the bf(C) library like tt(qsort). The
tt(qsort) function expects a pointer to a (comparison) function having two
tt(void const *) parameters. In fact, the tt(void const *)s point to data
elements of the array to sort, and so the comparison function may cast the
tt(void const *) parameters to pointers to the elements of the array to be
sorted. E.g., if the array is an tt(int array[]) and the compare function's
parameters are tt(void const *p1, void const *p2)
then the compare function may obtain the address of the tt(int) pointed to by
tt(p1) by using:
        centt(reinterpret_cast<int const *>(p1))

 Another example of a tt(reinterpret_cast) is found in combination with the
tt(write) functions that are available for files and streams. In bf(C++)
streams are the preferred interface to, e.g., files. Output
streams (like tt(cout)) offer tt(write) members having the prototype
        centt(write(char const *buffer, int length))
 To write a tt(double) to a stream using tt(write) a tt(reinterpret_cast) is
needed as well. E.g., to write the raw bytes of a variable tt(double value) to
tt(cout) we would use:
        verb(
    cout.write(reinterpret_cast<char const *>(&value), sizeof(double));
        )
    All casts are potentially dangerous, but the tt(reinterpret_cast) is the
most dangerous of all casts. Effectively we tell the compiler: back off, we
know what we're doing, so stop fuzzing. All bets are off, and we'd better
em(do) know what we're doing in situations like these. As a case in point
consider the following code:
        verb(
    int value = 0x12345678;     // assume a 32-bits int

    cout << "Value's first byte has value: " << hex <<
            static_cast<int>(
                *reinterpret_cast<unsigned char *>(&value)
                            );
    )
    The above code will show different results on little and big endian
computers. Little endian computers will show the value 78, big endian
computers the value 12. Also note that the different representations used by
little and big endian computers renders the previous example
(tt(cout.write(...))) non-portable over computers of different architectures.

As a i(rule of thumb): if circumstances arise in which casts em(have) to be
used, clearly document the reasons for their use in your code, making double
sure that the cast will not eventually cause a program to misbehave.
