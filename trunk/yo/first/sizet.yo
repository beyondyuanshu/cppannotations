The ti(size_t) type is not really a built-in primitive data type, but a data
type that is promoted by bi(POSIX) as a typename to be used for non-negative
integral values. It is not a specific bf(C++) type, but also available in,
e.g., bf(C). It should be used instead of ti(unsigned int). Usually it is
defined implictly when a system header file is included. The header file
`officially' defining tt(size_t) in the context of bf(C++) is ti(cstddef).

Using tt(size_t) has the advantage of being a em(conceptual) type, rather than
a standard type that is then modified by a modifier. Thus, it improves
the self-documenting value of source code.

The type tt(size_t) should be used in all situations where non-negative
integral values are intended. Sometimes functions explictly require
tt(unsigned int) to be used. E.g., on ti(amd)-architectures the i(X-windows)
function ti(XQueryPointer) explicitly requires a pointer to a tt(unsigned int)
variable as one of its arguments. In this particular situation a pointer to a
tt(size_t) variable can't be used. This situation is exceptional,
though. Usually a tt(size_t) can (and should) be used where unsigned values
are intended.

Other useful bit-represented types also exists. E.g., ti(uns32_t) is
guaranteerd to hold 32-bits unsigned values. Analogously, ti(int32_t) holds
32-bits signed values. Corresponding types exist for 8, 16 and 64 bits
values. These types are defined in the header file ti(stdint.h).
