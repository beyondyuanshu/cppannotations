bf(C++)'s  i(keywords) are a superset of bf(C)'s  keywords. Here is a
list of all keywords of the language:
    COMMENT(table generated by src/keywordsort.cc)
        verb(
alignof compl        explicit namespace        return      typeid   
and     concept      export   new              short       typename 
and_eq  const        extern   not              signed      union    
asm     const_cast   false    not_eq           sizeof      unsigned 
auto    constexpr    float    nullptr          static      using    
axiom   continue     for      operator         static_cast virtual  
bitand  decltype     friend   or               struct      void     
bitor   default      goto     or_eq            switch      volatile 
bool    delete       if       private          template    wchar_t  
break   do           import   protected        this        while    
case    double       inline   public           throw       xor      
catch   dynamic_cast int      register         true        xor_eq   
char    else         long     reinterpret_cast try                  
class   enum         mutable  requires         typedef              
    )

    Notes:
    itemization(
    it() The ti(export) keyword is removed from the language under the C++11
standard, but remains a keyword, reserved for future use.
    it()  the emi(operator keywords): tt(and, and_eq, bitand, bitor, compl,
not, not_eq, or, or_eq, xor) and tt(xor_eq) are symbolic alternatives for,
respectively, tt(&&, &=, &, |, ~, !, !=, ||, |=, ^) and tt(^=).
    it() C++11 also recognizes the special identifiers tt(final) and
tt(override). These identifiers are special in the sense that they acquire
special meanings when declaring classes or polymorphic functions. Section
ref(FINAL) provides further details.
    )

Keywords can only be used for their intended purpose and cannot be used as
names for other entities (e.g., variables, functions, class-names, etc.). In
addition to keywords i(identifiers starting with an underscore) and living in
the emi(global namespace) (i.e., not using any explicit namespace or using the
mere tt(::) namespace specification) or living in the em(std namespace) are
 i(reserved identifiers) in the sense that their use is a prerogative of the
implementor.
