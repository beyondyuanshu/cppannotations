To erase a type from a tt(TypeList) by its index we again use a
recursive template meta program. tt(EraseIdx) expects a tt(size_t) index value
and a tt(TypeList) from which its tt(idx)sup(th) type must be
erased. tt(EraseIdx) defines the type tt(List) containing the resulting
tt(TypeList). Here is the algorithm:
    itemization(
    it() The foundation of the algorithm consists of a struct template
tt(EraseIdx) expecting the index of the type to erase and a tt(TypeList):
            verbinsert(ERASEIDX)(advancedtemplates/examples/erase.h)
    it() If the typelist is empty, there's nothing to erase, and an empty
        tt(TypeList) results:
            verbinsert(ERASEIDXEMPTY)(advancedtemplates/examples/erase.h)
    it() The recursion otherwise ends once tt(idx) becomes 0. At that point
        the tt(TypeList)'s first type is ignored and tt(Type) is initialized
        to a tt(TypeList) containing the types in the orginal tt(TypeList)'s
        tail:
            verbinsert(ERASEIDXZERO)(advancedtemplates/examples/erase.h)
    it() In all other cases tt(EraseIdx) is applied to the tt(TypeList)'s
        tail, providing it with a decremented value of tt(idx). To the
        resulting tt(TypeList) the orginal tt(TypeList)'s head is
        prefixed. The tt(TypeList) returned by the prefix operation is then
        returned as tt(EraseIdx::Type):
            verbinsert(ERASEIDXNEXT)(advancedtemplates/examples/erase.h)
    )
    Here is a statement showing how tt(EraseIdx) can be used:
            verbinsert(ERASEIDX)(advancedtemplates/examples/erase.cc)
