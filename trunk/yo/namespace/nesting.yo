Namespaces can be nested. The following code shows the definition of a
i(nested namespace):
        verb(
    namespace CppAnnotations
    {
        namespace Virtual
        {
            void *pointer;
        }
    }
        )
    Now the variable tt(pointer) is defined in the tt(Virtual) namespace,
nested under the tt(CppAnnotations) namespace. In order to refer to this
variable, the following options are available:
    startit()
        it() The em(fully qualified name) can be used. A fully qualified name
of an entity is a list of all the namespaces that are visited until the
definition of the entity is reached, glued together by the scope resolution
operator:
        verb(
    int main()
    {
        CppAnnotations::Virtual::pointer = 0;
    }
        )
        it() A tt(using) declaration for tt(CppAnnotations::Virtual) can be
used. Now tt(Virtual) can be used without any prefix, but
tt(pointer) must be used with the tt(Virtual::) prefix:
        verb(
    ...
    using CppAnnotations::Virtual;

    int main()
    {
        Virtual::pointer = 0;
    }
        )
        it() A tt(using) declaration for tt(CppAnnotations::Virtual::pointer)
can be used. Now tt(pointer) can be used without any prefix:
        verb(
    ...
    using CppAnnotations::Virtual::pointer;

    int main()
    {
        pointer = 0;
    }
        )
        it() A tt(using) directive or directives can be used:
        verb(
    ...
    using namespace CppAnnotations::Virtual;

    int main()
    {
        pointer = 0;
    }
        )
    Alternatively, two separate tt(using) directives could have been used:
        verb(
    ...
    using namespace CppAnnotations;
    using namespace Virtual;

    int main()
    {
        pointer = 0;
    }
        )

        it() A combination of tt(using) declarations and tt(using)
directives can be used. E.g., a tt(using) directive can be used for
the tt(CppAnnotations) namespace, and a tt(using) declaration can be used for
the tt(Virtual::pointer) variable:
        verb(
    ...
    using namespace CppAnnotations;
    using Virtual::pointer;

    int main()
    {
        pointer = 0;
    }
        )
    endit()
    At every tt(using) directive all entities of that namespace can be used
without any further prefix. If a namespace is nested, then that namespace can
also be used without any further prefix. However, the entities defined in the
nested namespace still need the nested namespace's name. Only by using a
tt(using) declaration or directive the qualified name of the
nested namespace can be omitted.

    When i(fully qualified names) are somehow preferred and a long form like
                   centt(CppAnnotations::Virtual::pointer)
    is at the same time considered too long, a emi(namespace alias) can be
used:
                centt(namespace CV = CppAnnotations::Virtual;)

    This defines tt(CV) as an em(alias) for the full name. So, to refer to the
tt(pointer) variable, we may now use the construction
        verb(
    CV::pointer = 0;
        )
    Of course, a namespace alias itself can also be used in a
tt(using) declaration or directive.
