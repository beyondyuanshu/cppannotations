Often constructors are specializations of each other, allowing objects to be
constructed using subsets of arguments for its data members, and/or using
default argument values for other data members. In many cases classes define
initialization members that are called by the various constructors. Here is an
example. A class tt(Stat) is designed as a wrapper class around bf(C)'s
ti(stat) function. It might define three constructors: one expecting no
arguments and initializing all data members to appropriate values; a second
one doing the same, but it calls tt(stat) with the filename provided to the
constructor and a third one expecting a filename and a search path for the
provided file name. Rather than repeating the initialization code in each
constructor, the common code can be factorized into a member tt(init()) which
is thereupon called by the constructors.

The C++0x standard offers an alternative to this design by allowing
constructors to call each other. The C++0x standard
allows constructors to call each other as shown in the following example:
        verb(
    class Stat
    {
        public:
            Stat()
            :
                // default initialization of members
            {}
            Stat(std::string const &fileName)
            :
                Stat()
            {
                set(fileName);
            }
            Stat(std::string const &fileName, std::string const &searchPath)
            :
                Stat()
            {
                set(fileName, searchPath);
            }
            ...
    };
        )
    There is one em(caveat): bf(C++) considers the object as fully constructed
once a constructor has normally finished. Once a constructor has finished the
class's destructor is guaranteed to be called (cf. chapter ref(MEMORY)) and so
remaining code must make sure that, e.g., all the class's pointer data members
remain in a valid state. Also, as a prelude to chapter ref(EXCEPTIONS),
realize that a destructor em(will) be called if a constructor throws an
exception after having completed the call to another constructor.

    bf(C++) allows static const integral data members to be initialized within
the hi(data member: initialization) class interfaces (cf. chapter
ref(StaticDataFun)). The i(C++0x) standard adds to this the facility to
provide all data members (const or non-const, integral or non-integral) with
a default initialization that is specified by the class interface.

    These default initializations may be overruled by constructors. E.g., if
the class tt(Stat) uses a data member tt(bool d_hasPath) which is tt(false) by
default but the third constructor (see above) should initialize it to tt(true)
then the following approach is possible:
        verb(
    class Stat
    {
        bool d_hasPath = false;

        public:
            Stat(std::string const &fileName, std::string const &searchPath)
            :
                d_hasPath(true)     // overrule the interface-specified
                                    // value
            {}
    };
        )
    Here tt(d_hasPath) receives its value only once: it's always initialized
to tt(false) except when the shown constructor is used in which case it is
initialized to tt(true).
